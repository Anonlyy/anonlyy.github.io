<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器渲染与Virtual DOM相关</title>
      <link href="/2018/09/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B8%8EVirtual-DOM%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/09/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B8%8EVirtual-DOM%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器如何渲染页面"><a href="#浏览器如何渲染页面" class="headerlink" title="浏览器如何渲染页面"></a>浏览器如何渲染页面</h2><p>作为一名web前端码农,每天都在接触着浏览器.长此以往我们都会有疑惑,浏览器是怎么解析我们的代码然后渲染的呢？弄明白浏览器的渲染原理,对于我们日常前端开发中的性能优化有重要意义。</p><p>所以今天我们来给大家详细说说浏览器是怎么渲染<code>DOM</code>的。</p><h3 id="浏览器渲染大致流程"><a href="#浏览器渲染大致流程" class="headerlink" title="浏览器渲染大致流程"></a>浏览器渲染大致流程</h3><p>首先,浏览器会通过请求的 <code>URL</code> 进行域名解析，向服务器发起请求,接收资源（<code>HTML</code>、<code>CSS</code>、<code>JS</code>、<code>Images</code>)等等,那么之后浏览器又会进行以下解析:</p><ol><li><p>解析HTML文档,生成<code>DOM Tree</code></p></li><li><p><code>CSS</code> 样式文件加载后，开始解析和构建 <code>CSS Rule Tree</code></p></li><li><p><code>Javascript</code> 脚本文件加载后， 通过 <code>DOM API</code> 和<code>CSSOM API</code> 来操作改动 <code>DOM Tree</code> 和 <code>CSS Rule Tree</code></p></li></ol><p>而解析完以上步骤后, 浏览器会通过<code>DOM Tree</code> 和<code>CSS Rule Tree</code>来构建 <code>Render Tree</code>(<strong>渲染树</strong>)。</p><p>根据渲染树来布局，以计算每个节点的几何信息。</p><p>最后将各个节点绘制到页面上。</p><h4 id="HTML解析"><a href="#HTML解析" class="headerlink" title="HTML解析"></a>HTML解析</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么解析的<code>DOM</code>树就是以下这样</p><p><img src="http://p53ff6x0c.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt></p><h4 id="CSS解析"><a href="#CSS解析" class="headerlink" title="CSS解析"></a>CSS解析</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rule 1 */</span> <span class="selector-tag">div</span> &#123; <span class="attribute">display</span>: block; <span class="attribute">text-indent</span>: <span class="number">1em</span>; &#125;</span><br><span class="line"><span class="comment">/* rule 2 */</span> <span class="selector-tag">h1</span> &#123; <span class="attribute">display</span>: block; <span class="attribute">font-size</span>: <span class="number">3em</span>; &#125;</span><br><span class="line"><span class="comment">/* rule 3 */</span> <span class="selector-tag">p</span> &#123; <span class="attribute">display</span>: block; &#125;</span><br><span class="line"><span class="comment">/* rule 4 */</span> <span class="selector-attr">[class="text"]</span> &#123; <span class="attribute">font-style</span>: italic; &#125;</span><br></pre></td></tr></table></figure><p><img src="http://p53ff6x0c.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%281%29.png" alt></p><p><code>CSS Rule Tree</code>会比照着<code>DOM</code>树来对应生成,在这里需要注意的就是CSS匹配DOM的规则。很多人都以为CSS匹配DOM树的速度会很快,其实不然。</p><blockquote><p>样式系统从最右边的选择符开始向左侧移动来匹配一条规则。样式系统会一直向左匹配选择符直到规则匹配完毕或者由于出错停止匹配.</p></blockquote><p>这里就衍生出一个问题,为什么解析CSS的时候选择<strong>从右往左</strong>呢？</p><p>为了匹配效率。</p><p>所有样式规则极有可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素，所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。</p><p>如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 <code>div</code>，回溯若干次才能确定匹配与否，效率很低。</p><p>可以看以下的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 111 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 222 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 333 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'yellow'</span>&gt;</span> 444 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jartto1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 111 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 222 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> 333 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'red'</span>&gt;</span> 555 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span><span class="selector-class">.jartto</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.yellow</span>&#123;</span><br><span class="line">   <span class="attribute">color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述例子，如果按从左到右的方式进行查找：<br>1.先找到所有 <code>div</code> 节点；<br>2.在 div 节点内找到所有的子 <code>div</code> ,并且是 <code>class = “jartto”</code><br>3.然后再依次匹配 <code>p span.yellow</code> 等情况；<br>4.遇到不匹配的情况，就必须回溯到一开始搜索的 <code>div</code> 或者 <code>p</code> 节点，然后去搜索下个节点，重复这样的过程。</p><p>试想一下，如果采用<code>从左至右</code>的方式读取 <code>CSS</code> 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的；而如果采取<code>从右向左</code>的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</p><p>所以浏览器 <code>CSS</code> 匹配核心算法的规则是以<code>从右向左</code>方式匹配节点的。这样做是为了减少无效匹配次数，从而匹配快、性能更优。</p><p><strong>CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去，……</strong></p><h4 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h4><p>经运行过<code>Javascript</code>脚本后解析出了最终的<code>DOM Tree</code> 和 <code>CSS Rule Tree</code>, 根据这两者,就能合成我们的<strong><code>Render  Tree</code></strong>,网罗网页上所有可见的 <code>DOM</code> 内容，以及每个节点的所有 <code>CSSOM</code> 样式信息。</p><p>为构建渲染树，浏览器大体上完成了下列工作：</p><ol><li>从 DOM 树的根节点开始遍历每个可见节点。<ul><li>某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。</li><li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点—不会出现在渲染树中，—因为有一个显式规则在该节点上设置了“display: none”属性。</li></ul></li><li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。</li><li>输出可见节点，连同其内容和计算的样式。</li></ol><h4 id="渲染的注意事项"><a href="#渲染的注意事项" class="headerlink" title="渲染的注意事项"></a>渲染的注意事项</h4><p>在这里要说下两个概念,一个是<code>repaint</code>和<code>reflow</code>，这两个是影响浏览器渲染的主要原因:</p><ul><li><p>Repaint–重绘,屏幕的某一部分要重新绘制,比如某个DOM元素的背景颜色改动了,但元素的位置大小没有改变。</p></li><li><p>Reflow–回流,代表着元素的几何尺寸(如位置、宽高、隐藏等)变了，我们需要重新<strong>验证并计算<code>Render Tree</code></strong>。是<code>Render Tree</code>的一部分或全部发生了变化。</p><p>由此可以看出,我们的<code>Reflow</code>的成本要比<code>Repaint</code>高的多,<strong>在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的</strong>。</p><p>这也是<code>JQuery</code>在移动端页面上使用的障碍。、</p></li></ul><p>我们来看一段<code>javascript</code>代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bstyle = <span class="built_in">document</span>.body.style; <span class="comment">// cache</span></span><br><span class="line"> </span><br><span class="line">bstyle.padding = <span class="string">"20px"</span>; <span class="comment">// reflow, repaint</span></span><br><span class="line">bstyle.border = <span class="string">"10px solid red"</span>; <span class="comment">//  再一次的 reflow 和 repaint</span></span><br><span class="line"> </span><br><span class="line">bstyle.color = <span class="string">"blue"</span>; <span class="comment">// repaint</span></span><br><span class="line">bstyle.backgroundColor = <span class="string">"#fad"</span>; <span class="comment">// repaint</span></span><br><span class="line"> </span><br><span class="line">bstyle.fontSize = <span class="string">"2em"</span>; <span class="comment">// reflow, repaint</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// new DOM element - reflow, repaint</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'dude!'</span>));</span><br></pre></td></tr></table></figure><p>当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。<strong>一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow</strong>。</p><p>虽然浏览器会帮我们优化<code>reflow</code>的操作,但在实际开发过程中,我们还是得通过几种方法去减少<code>reflow</code>的操作</p><h4 id="减少reflow-repaint的方法"><a href="#减少reflow-repaint的方法" class="headerlink" title="减少reflow/repaint的方法"></a>减少reflow/repaint的方法</h4><p><strong>1) 不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>,</span><br><span class="line">top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top  = top  + <span class="string">"px"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">el.className += <span class="string">" theclassname"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br></pre></td></tr></table></figure><p><strong>2）把DOM离线后修改。如：</strong></p><ul><li>使用documentFragment 对象在内存里操作DOM</li><li>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。</li><li>clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li></ul><p><strong>3）不要把DOM结点的属性值放在一个循环里当成循环里的变量。</strong>不然这会导致大量地读写这个结点的属性。</p><p><strong>4）千万不要使用table布局</strong>。因为可能很小的一个小改动会造成整个table的重新布局。 </p><p><strong>5）尽可能的修改层级比较低的DOM</strong>。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。 </p><hr><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><h3 id="Virtual-DOM是什么"><a href="#Virtual-DOM是什么" class="headerlink" title="Virtual DOM是什么?"></a>Virtual DOM是什么?</h3><p>​    大部分前端开发者对<code>Virtual DOM</code>这个词都很熟悉了,简单来讲，<code>Virtual DOM</code>就是在数据和真实 <code>DOM</code> 之间建立了一层缓冲层。当数据变化触发渲染后，并不直接更新到<code>DOM</code>上，而是先生成 <code>Virtual DOM</code>，与上一次渲染得到的 <code>Virtual DOM</code> 进行比对，在渲染得到的 <code>Virtual DOM</code> 上发现变化，然后将变化的地方更新到真实 <code>DOM</code> 上。 </p><h3 id="为什么说Virtual-DOM快"><a href="#为什么说Virtual-DOM快" class="headerlink" title="为什么说Virtual DOM快?"></a>为什么说Virtual DOM快?</h3><p><strong>1）DOM结构复杂,操作很慢 </strong></p><p>我们在控制台输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> div) &#123;</span><br><span class="line">    str = str + key + <span class="string">"\n"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure><p>可以很容易发现,我们的一个空div对象,他的属性就有几百个,所以说DOM的操作慢是可以理解的。不是浏览器不想好好实现DOM，而是DOM设计得太复杂，没办法。 </p><p><strong>2）JS计算很快</strong></p><p><a href="https://julialang.org/benchmarks/" target="_blank" rel="noopener">https://julialang.org/benchmarks/</a></p><p>Julia有一个Benchmark，<a href="https://link.zhihu.com/?target=http%3A//julialang.org/benchmarks/" target="_blank" rel="noopener">Julia Benchmarks</a>， 可以看到<code>Javascript</code>跟<code>C</code>语言很接近了，也就几倍的差距，跟Java基本也是一个量级。 这就说明，单纯的Javascript运行起来其实速度是很快的。 </p><p>而相对于<code>DOM</code>,我们原生的<code>JavaScript</code>对象处理起来则会更快更简单.</p><p>我们通过<code>JavaScript</code>,可以很容易的用<code>JavaScript</code>对象表示出来.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> olE = &#123;</span><br><span class="line">  tagName: <span class="string">'ul'</span>, <span class="comment">// 标签名</span></span><br><span class="line">  props: &#123; <span class="comment">// 属性用对象存储键值对</span></span><br><span class="line">    id: <span class="string">'ul-list'</span>,</span><br><span class="line">    class: 'list'</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ <span class="comment">// 子节点</span></span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 1"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 2"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 3"</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的HTML写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&apos;ol-list&apos;&gt;</span><br><span class="line">  &lt;li class=&apos;item&apos;&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;li class=&apos;item&apos;&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;li class=&apos;item&apos;&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>那么,既然我们可以用<code>javascript</code>来表示<code>DOM</code>，那么代表我们可以用<code>JavaScript</code>来构造我们的真实<code>DOM</code>树,当我们的<code>DOM</code>树需要更新了,那我们先渲染更改这个<code>JavaScript</code>构造的<code>Virtual DOM</code>树,再更新到真实DOM树上。</p><p> 所以<code>Virtual DOM</code>算法就是：</p><p>一开始先用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文</p><p>档当中。当状态变更时，重新构造一棵新的对象树。然后用新的树和旧的树进行比较两个树的差异。</p><p>然后把差异更新到旧的树上，最后再把整个变更写入真实 DOM。 </p><h3 id="简单Virtual-DOM-算法实现"><a href="#简单Virtual-DOM-算法实现" class="headerlink" title="简单Virtual DOM 算法实现"></a>简单Virtual DOM 算法实现</h3><h4 id="步骤一：用JS对象模拟DOM树-并构建"><a href="#步骤一：用JS对象模拟DOM树-并构建" class="headerlink" title="步骤一：用JS对象模拟DOM树,并构建"></a>步骤一：用JS对象模拟DOM树,并构建</h4><p>用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建虚拟DOM函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.tagName = tagName <span class="comment">// 标签名</span></span><br><span class="line">  <span class="keyword">this</span>.props = props <span class="comment">// 对应属性（如ID、Class）</span></span><br><span class="line">  <span class="keyword">this</span>.children = children <span class="comment">// 子元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际应用如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">'./element'</span>)</span><br><span class="line"><span class="comment">// 普通ul和li对象就可以表示为这样</span></span><br><span class="line"><span class="keyword">var</span> ul = el(<span class="string">'ul'</span>, &#123;<span class="attr">id</span>: <span class="string">'list'</span>&#125;, [</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 1'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 2'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 3'</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>现在<code>ul</code>只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个<code>ul</code>构建真正的<code>&lt;ul&gt;</code>元素： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建真实DOM函数</span></span><br><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName) <span class="comment">// 根据tagName构建</span></span><br><span class="line">  <span class="keyword">var</span> props = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) &#123; <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">    <span class="keyword">var</span> propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> children = <span class="keyword">this</span>.children || []</span><br><span class="line"></span><br><span class="line">  children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> childEl = (child <span class="keyword">instanceof</span> Element)</span><br><span class="line">      ? child.render() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">      : <span class="built_in">document</span>.createTextNode(child) <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的<code>render</code>方法会根据<code>tagName</code>去构建一个真实的<code>DOM</code>节点,设置节点属性,再递归到子元素构建:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ulRoot = ul.render() <span class="comment">// 将js构建的dom对象传给render构建</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ulRoot) <span class="comment">// 真实的DOM对象塞入body</span></span><br></pre></td></tr></table></figure><p>这样我们body中就有了ul和li的DOM元素了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="步骤二：比较两棵虚拟DOM树的差异"><a href="#步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="步骤二：比较两棵虚拟DOM树的差异"></a>步骤二：比较两棵虚拟DOM树的差异</h4><p>在这里我们假设对我们修改了某个状态或者某个数据,这就会产生新的虚拟DOM</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新DOM</span></span><br><span class="line"><span class="keyword">var</span> ol = el(<span class="string">'ol'</span>, &#123;<span class="attr">id</span>: <span class="string">'ol-list'</span>&#125;, [</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'ol-item'</span>&#125;, [<span class="string">'Item 1'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'ol-item'</span>&#125;, [<span class="string">'Item 2'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'ol-item'</span>&#125;, [<span class="string">'Item 3'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'ol-item'</span>&#125;, [<span class="string">'Item 4'</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧DOM</span></span><br><span class="line"><span class="keyword">var</span> ul = el(<span class="string">'ul'</span>, &#123;<span class="attr">id</span>: <span class="string">'list'</span>&#125;, [</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 1'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 3'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 2'</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>那么我们会和先和,刚刚上一次生成的虚拟DOM树进行比对.</p><p>我们应该都很清楚,virtual DOM算法的核心部分,就在比较差异这一部分,也就是所谓的 <code>diff</code>算法。</p><p>因为很少出现跨层级的移动。</p><p><code>diff</code>算法一般来说,都是同一层级比对同一层级的</p><p><img src="https://images2015.cnblogs.com/blog/328599/201704/328599-20170418103314493-66729150.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patch = &#123;</span><br><span class="line">    <span class="string">'REPLACE'</span> : <span class="number">0</span>, <span class="comment">// 替换</span></span><br><span class="line">    <span class="string">'REORDER'</span> : <span class="number">1</span>, <span class="comment">// 新增、删除、移动</span></span><br><span class="line">    <span class="string">'PROPS'</span> : <span class="number">2</span>, <span class="comment">// 属性更改</span></span><br><span class="line">    <span class="string">'TEXT'</span> : <span class="number">3</span> <span class="comment">// 文本内容更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，上面的<code>div</code>和新的<code>div</code>有差异，当前的标记是0，那么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组存储新旧节点的不同</span></span><br><span class="line">patches = [</span><br><span class="line">    <span class="comment">// 每个数组表示一个元素的差异</span></span><br><span class="line">    [ </span><br><span class="line">        &#123;difference&#125;, </span><br><span class="line">    &#123;difference&#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &#123;difference&#125;, </span><br><span class="line">    &#123;difference&#125;</span><br><span class="line">    ]  </span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [</span><br><span class="line">  &#123;</span><br><span class="line">  type: REPALCE,</span><br><span class="line">  node: newNode <span class="comment">// el('section', props, children)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  type: PROPS,</span><br><span class="line">    props: &#123;</span><br><span class="line">        id: <span class="string">"container"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,   </span><br><span class="line">  &#123;</span><br><span class="line">  type: REORDER,</span><br><span class="line">      moves: [</span><br><span class="line">          &#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">item</span>: item, <span class="attr">type</span>: <span class="number">1</span>&#125;, <span class="comment">// 保留的节点</span></span><br><span class="line">          &#123;<span class="attr">index</span>: <span class="number">0</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;, <span class="comment">// 该节点被删除</span></span><br><span class="line">          &#123;<span class="attr">index</span>: <span class="number">1</span>, <span class="attr">item</span>: item, <span class="attr">type</span>: <span class="number">1</span>&#125; <span class="comment">// 保留的节点</span></span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">如果是文本节点内容更改，就记录下：</span><br><span class="line">patches[<span class="number">2</span>] = [&#123;</span><br><span class="line">  type: TEXT,</span><br><span class="line">  content: <span class="string">"我是新修改的文本内容"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详细算法查看diff.js https://www.xposean.top/file/virtualDom/diff.js</span></span><br></pre></td></tr></table></figure><p>每种差异都会有不同的对比方式,通过比对后会将差异记录下来,应用到真实DOM上,并把最近最新的虚拟DOM树保存下来,以便下次比对使用。</p><h4 id="步骤三：把差异应用到真正的DOM树上"><a href="#步骤三：把差异应用到真正的DOM树上" class="headerlink" title="步骤三：把差异应用到真正的DOM树上"></a>步骤三：把差异应用到真正的DOM树上</h4><p>通过比对后,我们已经知道了,差异的节点是哪些,我们可以方便对真实DOM做最小化的修改。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详情看patch.js https://www.xposean.top/file/virtualDom/patch.js</span></span><br></pre></td></tr></table></figure><h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><p>到这里我们发现一个问题,不是说 <code>Virtual DOM</code>更快吗? 可是最终你还是要进行DOM操作呀?那意义何在？还不如一开始我们就直接进行DOM操作来的方便。</p><p>所以到这里我们要对<code>Virtual DOM</code> 有一个正确的认识</p><p><a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener">网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？</a></p><p><a href="http://chrisharrington.github.io/demos/performance/" target="_blank" rel="noopener">http://chrisharrington.github.io/demos/performance/</a></p><blockquote><p>最优更改</p></blockquote><p>Virtual DOM的算法能够向你保证的就是,每一次的DOM操作我都能达到算法上的理论最优,而如果是你自己去操作DOM,这并不能保证。</p><p>其次</p><blockquote><p>开发模式的更改</p></blockquote><p><strong>为了让开发者把精力集中在操作数据，而非接管 DOM 操作</strong>。Virtual DOM能让我们在实际开发过程中,不需要去理会复杂的DOM结构,而只需理会绑定DOM结构的状态和数据即可,这从开发上来说 就是一个很大的进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初探PWA的Service Worker</title>
      <link href="/2018/04/23/%E5%88%9D%E6%8E%A2PWA%E7%9A%84Service-Worker/"/>
      <url>/2018/04/23/%E5%88%9D%E6%8E%A2PWA%E7%9A%84Service-Worker/</url>
      
        <content type="html"><![CDATA[<p><strong>Progressive Web App</strong>, 简称 <strong>PWA</strong>，是提升<code>Web App</code>的体验的一种新方法，能给用户原生应用的体验，致力于用前沿的技术开发，让网页使用如同<strong>原生App</strong>般的体验的一系列<strong>方案</strong>。</p><p>用来自<strong>Google Developers</strong>的解答<code>Progressive Web Apps</code>:</p><ul><li><strong>渐进式</strong> - 适用于所有现代浏览器，因为它是以渐进式增强作为宗旨开发的</li><li><strong>离线使用</strong> - 借助 <code>Service Worker</code> 能够在离线或者网络较差的情况下正常访问</li><li><strong>可安装</strong> - 用户可以添加到桌面并生成快捷方式,一键访问</li><li><strong>类似应用</strong> - 由于是在 <a href="https://developers.google.cn/web/fundamentals/architecture/app-shell" target="_blank" rel="noopener"><code>App Shell</code></a> 模型基础上开发，因为应具有 <code>Native App</code> 的交互和导航，给用户 <code>Native App</code> 的体验</li><li><strong>持续更新</strong> - 始终是最新的，无版本和更新问题</li><li><strong>安全</strong> - 通过 <code>HTTPS</code> 协议提供服务，防止窥探和确保内容不被篡改</li><li><strong>可索引</strong> - 应用清单文件和 <code>Service Worker</code> 可以让搜索引擎索引到，从而将其识别为『应用』</li><li><strong>粘性</strong> - 网页已经关闭的情况下还可以通过<a href="https://zhangxinxu.github.io/https-demo/notification/basic.html" target="_blank" rel="noopener">推送后台通知</a>等，让用户回流</li></ul><p>我们也可以通过一个DEMO看看实际效果=&gt;<a href="https://weatherpwa.baidu.com/" target="_blank" rel="noopener">天气 PWA</a></p><p>而其中,<strong>PWA方案</strong>的最主要核心功能都是依赖于<code>Service Worker</code>这个API来实现的.</p><hr><h2 id="Service-Worker是什么呢"><a href="#Service-Worker是什么呢" class="headerlink" title="Service Worker是什么呢?"></a>Service Worker是什么呢?</h2><p>W3C 组织早在 2014 年 5 月就提出过 <code>Service Worker</code>这样的一个 HTML5 API ，主要用来做持久的离线缓存。</p><p>当然这个 API 不是凭空而来，至于其中的由来我们可以简单的捋一捋：</p><p>浏览器中的<code>javaScript</code> 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，我们逐渐在 js 中加了很多耗资源、耗时间的复杂运算过程，这些过程导致的性能问题在 WebApp 的复杂化过程中更加凸显出来。</p><p>W3C 组织早早的洞察到了这些问题可能会造成的影响，这个时候有个叫<code>Web Worker</code> 的 API 被造出来了，这个 API 的唯一目的就是解放主线程，<code>Web Worker</code> 是脱离在主线程之外的，将一些复杂的耗时的活交给它干，完成后通过 <code>postMessage</code> 方法告诉主线程，而主线程通过 <code>onMessage</code> 方法得到 <code>Web Worker</code> 的结果反馈。</p><p>一切问题好像是解决了，但 Web Worker 是临时(即浏览器关闭后就关闭了)的，我们能不能有一个东东是一直持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求推出了最初版本的 <code>Service Worker</code> ，<code>Service Worker</code> 在 <code>Web Worker</code> 的基础上加上了持久离线缓存能力.</p><p><code>Service Worker</code> 有以下功能和特性：</p><ul><li>一个<strong>独立</strong>的 worker 线程，独立于当前网页进程。</li><li>一旦被 <strong>install</strong>，就永远存在，除非被 uninstall </li><li>需要的时候可以直接唤醒，不需要的时候自动睡眠</li><li>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</li><li>离线内容开发者可控</li><li>能向客户端推送消息</li><li><strong>不能直接操作 DOM</strong></li><li>出于安全的考虑，必须在 <strong>HTTPS</strong> 环境下才能工作</li></ul><p>所以我们基本上知道了 <code>Service Worker</code> 的伟大使命，就是让缓存做到优雅和极致，让 Web App 相对于 Native App 的缺点更加弱化，也为开发者提供了对性能和体验的无限遐想。</p><h3 id="Service-Worker工作原理"><a href="#Service-Worker工作原理" class="headerlink" title="Service Worker工作原理"></a>Service Worker工作原理</h3><p><code>Service Worker</code>的技术核心是<code>Service Worker</code>脚本，它 是一种由<code>Javascript</code>编写的浏览器端代理脚本。</p><p>前端页面向内核发起注册时会将脚本地址通知内核，内核会启动独立进/线程加载<code>Service Worker</code>脚本并执行<code>Service Worker</code>安装及激活动作。成功激活后便进入空闲等待状态，若当前的<code>Service Worker</code>进/线程一直没有管辖的页面或者事件消息时会自动终止（具体的终止策略视不同浏览器及版本而定，不会影响前端编写逻辑，但前端勿在<code>Service Worker</code>脚本中保存需要持久化的信息，可以借助<code>localstorage</code>），当打开新的可管辖页面或者已管辖页面发起<code>message</code>等消息时，<code>Service Worker</code>进/线程会被重新唤起。</p><p>每当已安装的<code>Service Worker</code>有管辖页面被打开时，便会触发<code>Service Worker</code>脚本更新，当<code>Service Worker</code>脚本发生了更改，便会忽略本地网络<code>cache</code>的<code>Service Worker</code>脚本直接从网络拉取。若网络拉取的与本地有一个字节的差异都会触发<code>Service Worker</code>脚本的更新，更新流程与安装类似，只是在更新安装成功后不会立即进入<code>active</code>状态，需要等待旧版本的<code>Service Worker</code>进/线程终止。</p><p><img src="https://x5.tencent.com/tbs/img/article/sw-1.png" alt></p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在html里注册service-worker</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker != <span class="literal">null</span>) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'sw.js'</span>)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Registered events at scope: '</span>, registration.scope);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义需要缓存的路径, 以及需要缓存的静态文件的列表。</span></span><br><span class="line"><span class="keyword">var</span> cacheStorageKey = <span class="string">'minimal-pwa-8'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cacheList = [</span><br><span class="line">  <span class="string">'/'</span>,</span><br><span class="line">  <span class="string">"index.html"</span>,</span><br><span class="line">  <span class="string">"main.css"</span>,</span><br><span class="line">  <span class="string">"e.png"</span>,</span><br><span class="line">  <span class="string">"*.png"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助 Service Worker, 可以在注册完成安装 Service Worker 时, 抓取资源写入缓存:</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Cache event!'</span>)</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheStorageKey).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Adding to Cache:'</span>, cacheList)</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(cacheList) </span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Skip waiting!'</span>)</span><br><span class="line">      <span class="keyword">return</span> self.skipWaiting()</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网页抓取资源的过程中, 在 Service Worker 可以捕获到 fetch 事件, 可以编写代码决定如何响应资源的请求:</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log('Fetch event:', e.request.url)</span></span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Using cache for:'</span>, e.request.url)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Fallback to fetch:'</span>, e.request.url)</span><br><span class="line">      <span class="keyword">return</span> fetch(e.request.url)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="关于事件"><a href="#关于事件" class="headerlink" title="关于事件"></a>关于事件</h3><p><strong>install</strong> 事件:当前<code>Service Worker</code>脚本被安装时，会触发 install 事件。</p><p><strong>push</strong>事件:<br>push 事件是为推送通知而准备的。不过首先你需要了解一下 <a href="http://www.zhangxinxu.com/wordpress/2016/07/know-html5-web-notification/" target="_blank" rel="noopener"><code>Notification API</code> </a>和 <code>PUSH API</code>。</p><p>通过 <code>PUSH API</code>，当订阅了推送服务后，可以使用推送方式唤醒 <code>Service Worker</code> 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。</p><p><strong>online/offline</strong>事件:<br>当网络状态发生变化时，会触发 <code>online</code> 或 <code>offline</code> 事件。结合这两个事件，可以与 <code>Service Worker</code> 结合实现更好的离线使用体验，例如当网络发生改变时，替换/隐藏需要在线状态才能使用的链接导航等。</p><p><strong>fetch</strong> 事件：<br>当我们安装完<code>Service Worker</code>成功并进入激活状态后即运行于浏览器后台,我们的这个线程就会一直监控我们的页面应用,如果出现<code>HTTP</code>请求,那么就会触发<code>fetch</code>事件，并且给出自己的响应。<br>这个功能是十分强大的,借助 <code>Fetch API</code> 和 <code>Cache API</code> 可以编写出复杂的策略用来区分不同类型或者页面的资源的处理方式。它能够提供更加好的用户体验:<br>例如可以实现<strong>缓存优先、降级处理</strong>的策略逻辑：监控所有 http 请求，当请求资源已经在缓存里了，直接返回缓存里的内容；否则使用 fetch API 继续请求，如果是 图片或 css、js 资源，请求成功后将他们加入缓存中；如果是离线状态或请求出错，则降级返回预缓存的离线内容。</p><hr><h3 id="使用webpack插件"><a href="#使用webpack插件" class="headerlink" title="使用webpack插件"></a>使用webpack插件</h3><p>看到这里很多人会有疑问了,既然可以通过<code>service-worker</code>缓存资源,那如果一个正式项目,在项目迭代后,并将代码推送到正式环境后,前端怎么实时知道并重新缓存新的资源呢?</p><p>​    第一种方式,就是每次修改都手动去更改sw文件的版本号,触发更新。</p><p>​    第二种就是使用<code>webpack</code>插件自动化处理</p><p>事实上,在我们真实的用<code>webpack</code>生成的项目中,如果按照第一种方式手动去写<code>Service-worker.js</code>文件的话，会遇到两个问题:</p><ol><li><code>webpack</code>生成的资源多会生成一串hash，<code>Service-worker.js</code>的资源列表里面需要同步更新这些带hash的资源； </li><li>每次更新代码，都需要通过更新<code>service-worker</code>文件版本号来通知客户端对所缓存的资源进行更新.</li></ol><p>看到这里就该让用<code>webpack</code>插件:<a href="https://github.com/NekR/offline-plugin" target="_blank" rel="noopener">offline-plugin</a> 登场了,官方同时也推荐<a href="https://github.com/goldhand/sw-precache-webpack-plugin" target="_blank" rel="noopener">sw-precache-webpack-plugin</a> ,<a href="https://github.com/NekR/offline-plugin" target="_blank" rel="noopener">offline-plugin</a>不仅能够解决刚刚那个提到的缓存更新的问题,同时还具备以下的优点:</p><ul><li>1、自动生成和更新Service-worker.js文件和自动为SW添加缓存资源列表 </li><li>2、更为详细的文档和例子；</li><li>3、迭代频率相对更高，star数更多；</li><li>4、自动处理生命周期，用户无需纠结生命周期的坑；</li><li>5、支持自动生成<code>manifest</code>文件。 </li></ul><p>部署到项目中也十分的简单</p><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install offline-plugin [--save-dev]</span><br></pre></td></tr></table></figure><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h4><p>第一步，进入<code>webpack.config.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OfflinePlugin = <span class="built_in">require</span>(<span class="string">'offline-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ... other plugins</span></span><br><span class="line">    <span class="comment">// it's always better if OfflinePlugin is the last plugin added</span></span><br><span class="line">    <span class="keyword">new</span> OfflinePlugin()</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-入口文件导入"><a href="#3-入口文件导入" class="headerlink" title="3.入口文件导入"></a>3.入口文件导入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as OfflinePluginRuntime from &apos;offline-plugin/runtime&apos;;</span><br><span class="line">OfflinePluginRuntime.install();</span><br></pre></td></tr></table></figure><p>经过上面的步骤，<code>offline-plugin</code>已经集成到项目之中，通过<code>webpack</code>构建即可。 </p><p>具体代码也可查看 <a href="https://github.com/NekR/offline-plugin" target="_blank" rel="noopener">demo</a></p><hr><h3 id="PWA的浏览器支持情况"><a href="#PWA的浏览器支持情况" class="headerlink" title="PWA的浏览器支持情况"></a>PWA的浏览器支持情况</h3><blockquote><p><a href="https://lavas.baidu.com/ready" target="_blank" rel="noopener">兼容性查看</a></p></blockquote><p>毕竟是自家产品,chrome浏览器肯定是支持度最高的浏览器,chrome64版本是基本支持所有PWA功能<code>API</code>的。</p><p>但国内的浏览器·支持情况相对差一些,而且chrome移动版的使用人群还是偏少的,不过在UC的支持程度也不低</p><p><img src="http://p53ff6x0c.bkt.clouddn.com/18-4-24/56137583.jpg" alt></p><p><img src="http://p53ff6x0c.bkt.clouddn.com/18-4-24/70665880.jpg" alt></p><p><img src="http://p53ff6x0c.bkt.clouddn.com/18-4-24/79002804.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>被严重低估的target=&#39;_blank&#39;漏洞问题</title>
      <link href="/2018/03/08/%E8%A2%AB%E4%B8%A5%E9%87%8D%E4%BD%8E%E4%BC%B0%E7%9A%84target-blank-%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/08/%E8%A2%AB%E4%B8%A5%E9%87%8D%E4%BD%8E%E4%BC%B0%E7%9A%84target-blank-%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在网页中使用链接时，如果想要让浏览器自动在新的标签页打开指定的地址，通常的做法就是在 a 标签上添加 target等于”_blank” 属性。</p></blockquote><blockquote><p>然而，就是这个属性，为钓鱼攻击者带来了可乘之机。</p></blockquote><h4 id="parent-与-opener"><a href="#parent-与-opener" class="headerlink" title="parent 与 opener"></a>parent 与 opener</h4><p>在说 <code>opener</code> 之前，可以先聊聊 <code>&lt;iframe&gt;</code> 中的 <code>parent</code>。<br>我们知道，在 <code>&lt;iframe&gt;</code>中提供了一个用于父子页面交互的对象，叫做 <code>window.parent</code>，我们可以通过 <code>window.parent</code> 对象来从框架中的页面访问父级页面的 <code>window</code>。<br><code>opener</code> 与 <code>parent</code> 一样，只不过是用于 <code>&lt;a target=&quot;_blank&quot;&gt;</code> 在新标签页打开的页面的。通过<br><code>&lt;a target=&quot;_blank&quot;&gt;</code> 打开的页面，可以直接使用 <code>window.opener</code> 来访问来源页面的 <code>window</code> 对象。</p><h4 id="重述攻击步骤"><a href="#重述攻击步骤" class="headerlink" title="重述攻击步骤"></a>重述攻击步骤</h4><p>1.比如在当前的页面上存在一个链接：<br>    <a href="https://www.xiee.com" target="_blank">进入一个“邪恶”的网站</a></p><p>当用户点击了这个链接，在新的标签页打开了这个网站。这个邪恶的网站上只要包含着类似于这样的 JavaScript 代码：</p><pre><code>&lt;script type=&apos;text/javascript&apos;&gt;    if  (window.opener)  {      window.opener.location.replace(&apos;https://www.baidu.com&apos;);    }&lt;/script&gt;</code></pre><p>那么此时，用户在继续浏览这个新的标签页，而原来的网站所在的标签页此时已经被导航到了 <code>https://www.baidu.com</code></p><p>上面的攻击步骤是在跨域的情况下的，在跨域情况下，opener 对象和 parent 一样，是受到限制的，仅提供非常有限的属性访问，并且在这仅有的几个属性中，大部分也都是不允许访问的（访问会直接抛出 DOMException）。<br>但是与 parent 不同的是，在跨域的情况下，opener 仍然可以调用 location.replace 方法而 parent 则不可以。</p><p>这样是十分可怕的,这就会有不法分子利用在论坛或是某些博客上的链接跳转到对应的钓鱼网站,而你的源网站可能已经被钓鱼网站给更改为高仿的登录页,当你关掉钓鱼网站,就会在高仿的登录页输入你的账号密码,导致账号密码泄露。</p><h4 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h4><p>为了安全，现代浏览器都支持在<code>&lt;a&gt;</code>标签的 <code>rel</code> 属性中指定 <code>rel=&quot;noopener&quot;</code>，这样，在打开的新标签页中，将无法再使用 <code>opener</code> 对象了，它设置为了 null。</p><pre><code>&lt;a href=&quot;https://an.evil.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进入一个“邪恶”的网站&lt;/a&gt;</code></pre><p><code>noopener</code> 属性看似是解决了所有问题，但是…浏览器的兼容性问题…<br><img src="http://p53ff6x0c.bkt.clouddn.com/18-3-8/57689117.jpg" alt><br>可以看到，现在绝大多数浏览器都已经兼容了 <code>rel=&quot;noopener&quot;</code> 属性了。但是，为了保护稍旧的“近代”浏览器或是很旧的“古代”浏览器甚至是“远古”浏览器，只有<code>noopener</code> 属性还是远远不够的。</p><p>这时，就只能请出下面这段原生 JavaScript 来帮忙了。</p><pre><code>function openUrl(url) {  var newTab = window.open();  newTab.opener = null;  newTab.location = url;}</code></pre><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>如果网站使用了 <code>&lt;a target=&quot;_blank&quot;&gt;</code>，那么新打开的标签页的性能将会影响到当前页面。此时如果新打开的页面中执行了一个非常庞大的 <code>JavaScript</code> 脚本，那么原始标签页也会受到影响，会出现卡顿的现象（当然不至于卡死）。<br>而如果在链接中加入了 <code>noopener</code>，则此时两个标签页将会互不干扰，使得原页面的性能不会受到新页面的影响。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5.1和HTML5.2的新特性</title>
      <link href="/2018/03/08/HTML5-1%E5%92%8CHTML5-2%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018/03/08/HTML5-1%E5%92%8CHTML5-2%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>HTML5.1和HTML5.2提供很多新特性,但大部分都比较鸡肋,以下只列举部分有实际用处的特性.</p><h3 id="1-为响应设计定义多个图像资源"><a href="#1-为响应设计定义多个图像资源" class="headerlink" title="1.为响应设计定义多个图像资源"></a>1.为响应设计定义多个图像资源</h3><h4 id="srcset-图像属性"><a href="#srcset-图像属性" class="headerlink" title="srcset 图像属性"></a>srcset 图像属性</h4><p>srcset 属性让你可以指定一个多个可选的图像来源，对应于不同的像素分辨率。它将允许浏览器根据用户设备的不同选择合适质量的实现来进行显示。例如，对于使用网络比较慢的移动设备的用户，显示一张低分辨率的图片会比较好。</p><p>你可以使用 srcset 属性并且带上它自有的 x 修饰符来描述每一个图片的像素比例, 如果用户的像素比例等于 3，就会显示 high-res 这张图片。</p><pre><code>&lt;img src=&quot;clicks/low-res.jpg&quot; srcset=&quot;clicks/low-res.jpg 500w, clicks/medium-res.jpg 1000w,clicks/high-res.jpg 1600w&quot;&gt;</code></pre><h4 id="picture标签"><a href="#picture标签" class="headerlink" title="picture标签"></a>picture标签</h4><p>picture 元素让你可以针对不同的屏幕尺寸声明图片。这个可以通过用 <picture> 元素封装 <img> ，并且描述多个 <source> 子元素来实现。</picture></p><p><code>&lt;picture&gt;</code> 标记单独使用并不会显示任何东西。你已经被假定会声明默认的图像来源作为 src 属性的取值，而可选的图像来源则会放在 scrset 属性之中，如下所示：</p><pre><code>&lt;picture&gt;     &lt;source srcset=&quot;mobile.jpg, mobile-hd.jpg 2x&quot; media=&quot;(max-width: 360px)&quot;&gt;     &lt;source srcset=&quot;large.jpg, large-hd.jpg 2x&quot; media=&quot;(min-width: 1920px)&quot;&gt;     &lt;img src=&quot;default.jpg&quot; srcset=&quot;default-hd.jpg 2x&quot; alt=&quot;your image&quot;&gt; &lt;/picture&gt;</code></pre><h3 id="2-iframe支持更多的权限"><a href="#2-iframe支持更多的权限" class="headerlink" title="2.iframe支持更多的权限"></a>2.iframe支持更多的权限</h3><h4 id="iframe可以使用支付请求接口-allowpaymentrequest"><a href="#iframe可以使用支付请求接口-allowpaymentrequest" class="headerlink" title="iframe可以使用支付请求接口 allowpaymentrequest"></a>iframe可以使用支付请求接口 allowpaymentrequest</h4><p>在HTML5.2之前.对于支付请求的API是不能在iframe中来完成的.所以每次我们在进行移动支付时都需要跳转到另外一个支付页面才能完成付款.而现在,使用allowpaymentrequest属性应用在iframe上</p><pre><code>&lt;iframe allowpaymentrequest&gt;</code></pre><p>这样,就可以让iframe使用<code>Payment Request API</code>从而让</p><blockquote><p>嵌入了第三方内容的页面能够控制该第三方内容是否可向用户请求获取支付凭证，进而让可嵌入的购物车工具可以利用Payment Request API。</p></blockquote><blockquote><p>来自Forrester的Brendan Miller阐述了支付请求API所带来的好处，他说：该新标准让开发者可以创建一个简化的结帐页面，用户可以重复使用保存的付款和地址信息来加快结账速度，并减少错误输入。</p></blockquote><p>Payment Request API的兼容性:<br><img src="https://i.imgur.com/gm6lz5c.png" alt></p><h3 id="解决”-blank”的钓鱼攻击"><a href="#解决”-blank”的钓鱼攻击" class="headerlink" title="解决”_blank”的钓鱼攻击"></a>解决”_blank”的钓鱼攻击</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动设备引发的一像素边框问题</title>
      <link href="/2018/02/27/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E5%83%8F%E7%B4%A0%E8%BE%B9%E6%A1%86%E9%97%AE%E9%A2%98/"/>
      <url>/2018/02/27/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E5%83%8F%E7%B4%A0%E8%BE%B9%E6%A1%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>熟悉移动web开发的同学一定对<strong>1像素边框问题</strong>不陌生,随着移动端web项目越来越多,要求也越来越高，好多设计师都发现了，你们前端实现的边线为什么这么粗的，根本不是1像素，好吗？<br>一句很普通的<code>border: 1px solid white;</code>在PC端浏览器上会正常显示1px的边框,然而放在移动端时就不是1px的大小了，可以能是2px，也可能是1.5px等,这又是怎么回事呢？咱们继续往下看。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>讲原因我们得来认识几个关键词:</p><h3 id="设备像素比-devicePixelRatio"><a href="#设备像素比-devicePixelRatio" class="headerlink" title="设备像素比 devicePixelRatio"></a>设备像素比 devicePixelRatio</h3><blockquote><p>devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。<br>公式表示就是：devicePixelRatio(设备像素比) = 物理像素 / 设备独立像素(dips)</p></blockquote><p> <strong>物理像素：</strong><br>  物理像素（physical pixel）又称设备像素，设备能控制显示的最小单位，我们可以把这些像素看作成真实存在显示器上一个个的点.</p><p> <strong>设备独立像素:</strong><br>  也叫设备像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。</p><h3 id="物理像素与设备独立像素之间的关系"><a href="#物理像素与设备独立像素之间的关系" class="headerlink" title="物理像素与设备独立像素之间的关系"></a>物理像素与设备独立像素之间的关系</h3><p>在一定的条件下两者它们两者是可以相等的,比如：在PC端浏览器默认情况下（100%，即页面没被缩放），一个物理像素 = 一个设备独立像素。而在移动端可就不一样的，因为retina视网膜分辨率,<br>是苹果公司提出来的，可以把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度，目前大部分设备都用到了这种技术。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。也被称为视网膜显示屏。</p><p>得出结论:</p><ul><li>PC端浏览器因为物理像素=设备独立像素,所以一般情况下,设备像素比 devicePixelRatio等于1。</li><li>而移动端因为为了更清晰的显示效果,使用了视网膜显示屏,所以物理像素不断地提高,但独立设备像素没有对应的提高,所以导致设备像素比 devicePixelRatio&gt;1。</li></ul><p>也就是说,以iphone8为例，其min-device-pixel-ratio的值为2，如果某元素的下边框的写法是：border: 1px solid color，即当PC端显示的是1px的下边框时，在iphone6中显示的就不是1px，而是2px;</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>经过搜集,解决方案有很多种,经过推敲,有两种方案是比较灵活,适合放到项目中的.</p><h3 id="1-伪类-transform-实现"><a href="#1-伪类-transform-实现" class="headerlink" title="1.伪类 + transform 实现"></a>1.伪类 + transform 实现</h3><pre><code>&lt;style&gt;    .scale-1px{      position: relative;      border:none;    }    //设备像素比为1.5    @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5),(min--moz-device-pixel-ratio: 2),(min-resolution: 2dppx) {        .scale-1px:::after {            content: &apos;&apos;;            position: absolute;              bottom: 0;              background: #000;              width: 100%;              height: 1px;              -webkit-transform: scaleY(1/1.5);              transform: scaleY(0.5);        }    }    //设备像素比为2    @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2),(min--moz-device-pixel-ratio: 2),(min-resolution: 2dppx) {        .scale-1px:::after {            content: &apos;&apos;;            position: absolute;              bottom: 0;              background: #000;              width: 100%;              height: 1px;              -webkit-transform: scaleY(0.5);              transform: scaleY(0.5);        }    }    //设备像素比为3    @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3),(min--moz-device-pixel-ratio: 3),(min-resolution: 3dppx) {        .scale-1px:::after {            content: &apos;&apos;;            position: absolute;              bottom: 0;              background: #000;              width: 100%;              height: 1px;              -webkit-transform: scaleY(1/3);              transform: scaleY(0.5);        }    }&lt;/style&gt;</code></pre><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul><li>所有场景都能满足</li><li>支持圆角(伪类和本体类都需要加border-radius)</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><ul><li>对于已经使用伪类的元素(例如clearfix)，可能需要多层嵌套</li></ul><h3 id="2-viewport-rem-实现"><a href="#2-viewport-rem-实现" class="headerlink" title="2.viewport + rem 实现"></a>2.viewport + rem 实现</h3><p>同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。</p><pre><code>&lt;script&gt;         var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);      //下面是根据设备像素设置viewport    if (window.devicePixelRatio == 1.5) {         viewport.setAttribute(&apos;content&apos;, &apos;width=device-width,initial-scale=0.6666666666666667, maximum-scale=0.6666666666666667, minimum-scale=0.6666666666666667, user-scalable=no&apos;);      }      if (window.devicePixelRatio == 2) {         viewport.setAttribute(&apos;content&apos;, &apos;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&apos;);      }      if (window.devicePixelRatio == 3) {        viewport.setAttribute(&apos;content&apos;, &apos;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&apos;);      }      var docEl = document.documentElement;    var fontsize = 10 * (docEl.clientWidth / 320) + &apos;px&apos;;    docEl.style.fontSize = fontsize;   &lt;/script&gt; </code></pre><p>在devicePixelRatio = 1.5 时，输出viewport：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.6666666666666667, maximum-scale=0.6666666666666667, minimum-scale=0.6666666666666667, user-scalable=no&quot;&gt;</code></pre><p>在devicePixelRatio = 2 时，输出viewport：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt;</code></pre><p>在devicePixelRatio = 3 时，输出viewport：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&quot;&gt;</code></pre><blockquote><p>以上部分内容引用<a href="https://segmentfault.com/a/1190000007604842" target="_blank" rel="noopener">移动web 1像素边框 瞧瞧大公司是怎么做的</a><br><a href="https://juejin.im/entry/584e427361ff4b006cd22c7c" target="_blank" rel="noopener">7 种方法解决移动端 Retina 屏幕 1px 边框问题</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序生态数据分析和报告</title>
      <link href="/2018/02/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E6%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2018/02/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E6%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>以下数据来源于 <a href="http://index.aldwx.com/bg" target="_blank" rel="noopener">阿拉丁指数行业报告</a></p><blockquote><p>月独立设备数（Monthly Unique Devices）<br>该月使用过该APP的设备总数，单个设备重复使用不重复统计。</p></blockquote><p><img src="https://i.imgur.com/2meIxQ4.png" alt></p><p><img src="https://i.imgur.com/H322QSY.png" alt></p><p><img src="https://i.imgur.com/nK8LDnX.png" alt></p><p><img src="https://i.imgur.com/FMmGJoc.png" alt></p><p><img src="https://i.imgur.com/naYDNHJ.png" alt></p><p><img src="https://i.imgur.com/UN8QqY8.png" alt></p><p><img src="https://i.imgur.com/Hk3uaN3.png" alt></p><p><img src="https://i.imgur.com/Uz8rvqC.png" alt></p><p><img src="https://i.imgur.com/Bo5vZMe.png" alt></p><p><img src="https://i.imgur.com/2iaHaKG.png" alt></p><h2 id="典型案例：麦当劳小程序用积分兑换提高用户粘性和注册会员数"><a href="#典型案例：麦当劳小程序用积分兑换提高用户粘性和注册会员数" class="headerlink" title="典型案例：麦当劳小程序用积分兑换提高用户粘性和注册会员数"></a>典型案例：麦当劳小程序用积分兑换提高用户粘性和注册会员数</h2><p><img src="https://i.imgur.com/7b5RAEg.png" alt></p><p><img src="https://i.imgur.com/lLMBWli.png" alt></p><p><img src="https://i.imgur.com/UtRYFuY.png" alt></p><h2 id="摩拜单车、OFO"><a href="#摩拜单车、OFO" class="headerlink" title="摩拜单车、OFO"></a>摩拜单车、OFO</h2><p><img src="https://i.imgur.com/djaQaYJ.png" alt></p><p><img src="https://i.imgur.com/lsF4xjm.png" alt></p><p><img src="https://i.imgur.com/H2fgygt.png" alt></p><p><img src="https://i.imgur.com/YjvqSOh.png" alt></p><h2 id="2018趋势"><a href="#2018趋势" class="headerlink" title="2018趋势"></a>2018趋势</h2><p><img src="https://i.imgur.com/C29PJpX.png" alt></p><p><img src="https://i.imgur.com/XjxGfjF.png" alt></p><p><img src="https://i.imgur.com/kbKeDrK.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>来聊聊优雅的Icon</title>
      <link href="/2018/01/24/%E6%9D%A5%E8%81%8A%E8%81%8A%E4%BC%98%E9%9B%85%E7%9A%84icon/"/>
      <url>/2018/01/24/%E6%9D%A5%E8%81%8A%E8%81%8A%E4%BC%98%E9%9B%85%E7%9A%84icon/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做前端后台项目的时候经常会用到很多 <code>icon</code> 图标，刚开始还好，但随着项目的不断迭代，每次修改添加图标会变得很麻烦，而且总觉得不够优雅，就开始琢磨着有啥简单方便的工作流呢？</p><h2 id="Icon发展史"><a href="#Icon发展史" class="headerlink" title="Icon发展史"></a>Icon发展史</h2><h3 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a>雪碧图</h3><p>在我刚开始实习时，大部分图标都是用 img 来实现的。渐渐发现一个页面的请求资源中图片 img 占了大部分，所以为了优化有了image sprite 就是所谓的雪碧图，就是将多个图片合成一个图片，然后利用 css 的 background-position 定位显示不同的 icon 图标。<br><img src="https://i.imgur.com/QrDbmyK.png" alt></p><h4 id="制作雪碧图"><a href="#制作雪碧图" class="headerlink" title="制作雪碧图"></a>制作雪碧图</h4><p>1.photoShop手动制作后生成<br>  这种方式是最费时费力的方式,在多数情况并不使用。</p><p>2.通过在线网站或客户端直接生成<br>  如<a href="http://alloyteam.github.io/gopng/###" target="_blank" rel="noopener">GO!PNG</a>、<a href="https://www.toptal.com/developers/css/sprite-generator" target="_blank" rel="noopener">sprite-generator</a>、<a href="http://www.99css.com/cssgaga/" target="_blank" rel="noopener">CssGaga</a><br>3.Gulp实现雪碧图自动合成<br>  安装Gulp插件<code>sprity</code>并配置icon路径,会生成对应的雪碧图和css,详情可查看<a href="https://segmentfault.com/a/1190000002910313" target="_blank" rel="noopener">教程</a></p><p>4.Webpack实现<br>  配置webpack环境后,安装雪碧图依赖模块：<a href="https://www.npmjs.com/package/webpack-spritesmith" target="_blank" rel="noopener">webpack-spritesmith</a>,并配置即可,此种方式和gulp类似</p><p>雪碧图虽好,但这个也有一个很大的痛点，<strong>维护困难</strong>。每新增一个图标，都需要改动原始图片，还可能不小心出错影响到前面定位好的图片.<br>于是就出现了下一种方式。</p><hr><h3 id="Iconfont"><a href="#Iconfont" class="headerlink" title="Iconfont"></a>Iconfont</h3><p>icon font ，图标字体，也叫字体图标，顾名思义，就是字体做的图标。因为他是矢量图标,能够自由的变化大小，且不会模糊,其次比图片小，加载快，还能够任意改变颜色，所以越来越多的图标都开始使用 icon font</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>每种字体在相同的字都是不一样的，比如 宋体 跟 微软雅黑 ，相同的字 ，由于调用的不同的字体，浏览器显示明显是有区别的。</p><p>在我们还不识字的时候，每个字都是一个图案，所以老师会告诉你哪个图案念什么 ，是什么字，iconfont 同理，我认为 三角形 是 a，那对于我来说，只要是 a ，就应该是个 三角形。</p><p>在电脑上，我给电脑规定 a 的样子是个 三角形，那么当显示 a 的时候，他就显示个三角形。</p><p>当我把网页上的所有图标都对应一个字符的时候，你在代码里输入某个字符，那这个字符就显示你规定的形状，这就是 iconfont 图标。</p><p>把所有的图标都放在一个字体里面，就是一个字体库了，然后按照正常字体库（本来就是正常的字体库）调用就行了。</p><p>也就是说,我们可以理解为每一个字体就是一个矢量图标,只是现在我们这个矢量图标不是<strong>字</strong>,而是一个<strong>图案</strong>.<br><img src="https://i.imgur.com/U7aQO1i.gif" alt><br><img src="https://i.imgur.com/FtkFFNC.png" alt></p><p>此外,为了保证兼容性,所以又有<code>.eot</code>、<code>.woff</code>、<code>.ttf</code>、<code>.svg</code>四种格式的字体文件.</p><h4 id="iconfont-三种使用方式"><a href="#iconfont-三种使用方式" class="headerlink" title="iconfont 三种使用方式"></a>iconfont 三种使用方式</h4><p><strong>unicode</strong></p><p>最开始我们使用了unicode的格式，它主要的特点是优势：</p><ol><li>兼容性最好，支持ie6+</li><li>支持按字体的方式去动态调整图标大小，颜色等等</li></ol><p>劣势：</p><ol><li>书写不直观，语意不明确</li><li>在不同的设备浏览器字体的渲染会略有差别</li><li>不支持多色图标</li></ol><pre><code>&lt;i class=&quot;iconfont&quot;&gt;&amp;#xe604;&lt;/i&gt;</code></pre><p><img src="https://i.imgur.com/gmBCWBw.png" alt></p><p><strong>font-class</strong></p><p>相比它也是我们日常开发中最常用到的,相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么，但只兼容IE8+。</p><pre><code>&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;</code></pre><p><img src="https://i.imgur.com/ySVgFUc.png" alt></p><p>它的主要原理其实是和 unicode 一样的，它只是多做了一步，将原先<code>&amp;#xe604</code>这种写法换成了<code>.icon-QQ</code>，它在每个 class 的 <code>before</code> 属性中写了<code>unicode</code>,省去了人为写的麻烦。如 </p><pre><code>.icon-QQ:before { content: &quot;\e604&quot;; }</code></pre><p>相对于<code>unicode</code>它的修改更加的方便与直观。但也有一个大坑，之前楼主一个项目中用到了两组<code>font-class</code> 由于没有做好命名空间，所有的<code>class</code>都是放在<code>.iconfont</code> 命名空间下的，一上线引发了各种雪崩问题，修改了半天，所以使用<code>font-class</code>一定要注意命名空间的问题。</p><p><strong>svg-sprite</strong></p><p>一个普通的SVG图标是这样的:</p><pre><code>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;24px&quot; height=&quot;24px&quot; viewBox=&quot;0 0 24 24&quot;&gt;     &lt;path fill=&quot;#E86C60&quot; d=&quot;M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;</code></pre><p>我们可以把SVG元素看成一个舞台，而symbol则是舞台上一个一个组装好的元件，这这些一个一个的元件就是我们即将使用的一个一个SVG图标。</p><p>于是,集合了三个SVG图标的SVG元素的代码就是这样的:</p><pre><code>&lt;svg&gt;    &lt;symbol id=&quot;icon-share&quot;&gt;        &lt;!-- 第1个图标路径形状之类代码 --&gt;        &lt;path fill=&quot;#E86C60&quot; d=&quot;M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z&quot;&gt;&lt;/path&gt;    &lt;/symbol&gt;    &lt;symbol id=&quot;icon-edit&quot;&gt;        &lt;!-- 第2个图标路径形状之类代码 --&gt;        &lt;path fill=&quot;#E86C60&quot; d=&quot;M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z&quot;&gt;&lt;/path&gt;    &lt;/symbol&gt;    &lt;symbol  id=&quot;icon-top&quot;&gt;        &lt;!-- 第3个图标路径形状之类代码 --&gt;        &lt;path fill=&quot;#E86C60&quot; d=&quot;M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z&quot;&gt;&lt;/path&gt;    &lt;/symbol&gt;&lt;/svg&gt;</code></pre><p>但是，<code>&lt;symbol&gt;</code>元素不会被直接显示，大概相当于定义一个模板，然后使用<code>&lt;use&gt;</code>元素引用并进行渲染。</p><p>也就是说上面的svg元素还要加上这样的一句话才能显示:</p><pre><code>&lt;svg&gt;&lt;use xlink:href=&quot;#icon-share&quot; /&gt;&lt;/svg&gt;</code></pre><p><img src="https://i.imgur.com/uYBI3Mv.png" alt></p><p>使用方法：第一步：拷贝项目下面生成的symbol代码,该js包含了所有SVG图标：</p><pre><code>&lt;script src=&quot;./iconfont.js&quot;&gt;&lt;/script&gt;</code></pre><p>第二步：加入通用css代码（引入一次就行）：</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .icon {       width: 1em; height: 1em;       vertical-align: -0.15em;       fill: currentColor;       overflow: hidden;    }&lt;/style&gt;</code></pre><p>第三步：挑选相应图标并获取类名，应用于页面：</p><pre><code>&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;    &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt;</code></pre><p>SVGIcon的好处:</p><ul><li>支持多色图标了，不再受单色限制。</li><li>支持像字体那样通过font-size,color来调整样式。</li><li>无须像font那样引入多个字体库文件(woff|eot|ttf)</li><li>支持 ie9+</li><li>可利用CSS实现动画。</li><li>减少HTTP请求。</li><li>矢量，缩放不失真</li><li>可以很精细的控制SVG图标的每一部分</li></ul><h4 id="如何生成或制作SVG图标"><a href="#如何生成或制作SVG图标" class="headerlink" title="如何生成或制作SVG图标"></a>如何生成或制作SVG图标</h4><p>生成的方式有很多种:</p><p>1.设计师使用AI(Adobe illustrator)的时候就可以直接生成SVG图标。<br>2.<a href="http://iconfont.cn" target="_blank" rel="noopener">阿里iconfont</a>直接生成SVG，极其方便<br>3.<a href="https://icomoon.io/" target="_blank" rel="noopener">IcoMoon</a>导出时可选择SVG和iconfont、PNG三种方式<br>4.<code>webpack</code>的<code>svg-sprite-loader</code>,可将多个svg打包成<code>SVG-sprite</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文大概的讲述了一下ICON使用的发展史<br>总的来说还是那句话，适合的才是最好的。根据自己项目的兼容性和业务场景选择自己合适的icon方式,所有方案都没有绝对的优与劣之分，适合自己业务场景，解决自己实际痛点，提高自己开发效率的方案就是好的方案。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前后端开发中的MVVM开发模式</title>
      <link href="/2018/01/17/%E6%B5%85%E8%B0%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84MVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/01/17/%E6%B5%85%E8%B0%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84MVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>之前在我的博客也写过关于MVVM模式的简单介绍,但不够详细,也因为对 MVVM 模式一直只是模模糊糊的认识，现在就给大家讲一下详细讲下MVVM模式为何物.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>MVVM</code> 源自于经典的 Model–View–Controller（MVC）模式（期间还演化出了 Model-View-Presenter（MVP）模式，可忽略不计）。<br>MVC模式的业务逻辑主要集中在Controller，而前端的View其实已经具备了独立处理用户事件的能力，当每个事件都流经Controller时，这层会变得十分臃肿。</p><p><code>MVVM</code> 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。MVVM 的核心是 <strong>ViewModel层</strong>，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p><p><img src="https://i.imgur.com/naMyZKg.png" alt></p><p>MVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。KnockoutJS 是最早实现 MVVM 模式的前端框架之一，当下流行的 MVVM 框架有 <code>Vue</code>，<code>Angular</code> 等。</p><h2 id="MVVM架构组成"><a href="#MVVM架构组成" class="headerlink" title="MVVM架构组成"></a>MVVM架构组成</h2><p><img src="https://i.imgur.com/seNdEI9.png" alt></p><h3 id="View-层"><a href="#View-层" class="headerlink" title="View 层"></a>View 层</h3><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Marko、Pug、Jinja2等等，各大 MVVM 框架如 KnockoutJS，Vue，Angular 等也都有自己用来构建用户界面的内置模板语言。</p><hr><h3 id="Model-层"><a href="#Model-层" class="headerlink" title="Model 层"></a>Model 层</h3><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。后端的处理通常会非常复杂：</p><p>后端业务处理再复杂跟我们前端也没有半毛钱关系，只要后端保证对外接口足够简单就行了，我请求api，你把数据返出来，咱俩就这点关系，其他都扯淡。</p><hr><h3 id="ViewModel-层"><a href="#ViewModel-层" class="headerlink" title="ViewModel 层"></a>ViewModel 层</h3><p><code>ViewModel</code> 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 <code>Model</code> 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 <code>ViewModel</code> 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示），而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 <code>ViewModel</code> 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，<code>ViewModel</code> 的内容会实时展现在 <code>View</code> 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 <code>DOM</code> 去更新视图，<code>MVVM</code> 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 <code>ViewModel</code>，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。看到了吧，<code>View</code> 层展现的不是 <code>Model</code> 层的数据，而是 <code>ViewModel</code> 的数据，由 <code>ViewModel</code> 负责与 <code>Model</code> 层交互，这就完全解耦了<code>View</code> 层和 <code>Model</code> 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p><hr><h2 id="举一个栗子"><a href="#举一个栗子" class="headerlink" title="举一个栗子"></a>举一个栗子</h2><p>扯了这么多，并没有什么卵用。千言万语不如一个栗子来的干脆，下面用一个 Vue 实例来说明 MVVM 的具体表现。</p><p>Vue 的 View 模板：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;{{message}}&lt;/p&gt;    &lt;button @click=&quot;showMessage()&quot;&gt;Click me&lt;/button&gt;&lt;/div&gt;</code></pre><p>Vue 的 ViewModel 层（下面是伪代码）：</p><pre><code>var app = new Vue({    el: &apos;#app&apos;,    data: {     // 用于描述视图状态（有基于 Model 层数据定义的，也有纯前端定义）        message: &apos;Hello Vue!&apos;,  // 纯前端定义        server: {}, // 存放基于 Model 层数据的二次封装数据    },    methods: {  // 用于描述视图行为（完全前端定义）        showMessage(){            let vm = this;            alert(vm.message);        }    },    created(){            let vm = this;            // Ajax 获取 Model 层的数据            this.$axios.get(&apos;/your/server/data/api&apos;).then(                result=&gt;{console.log(result);}            );        }})</code></pre><p>在MVVM中，我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为（格式化数据由View的负责），这里可以把它理解为一个类似json的数据对象。</p><pre><code>{    &quot;url&quot;: &quot;/your/server/data/api&quot;,    &quot;res&quot;: {        &quot;success&quot;: true,        &quot;name&quot;: &quot;IoveC&quot;,        &quot;domain&quot;: &quot;www.cnblogs.com&quot;    }}</code></pre><p>这就是完整的 MVVM 编程模式。</p><h2 id="MVVM的优点"><a href="#MVVM的优点" class="headerlink" title="MVVM的优点"></a>MVVM的优点</h2><p>1.<strong>低耦合</strong><br>视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p>2.<strong>可重用性</strong><br>你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p><p>3.<strong>前后端协同开发</strong><br>开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p><p>4.<strong>容易测试</strong><br>界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入研究微信小程序的wepy框架</title>
      <link href="/2017/12/30/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84wepy%E6%A1%86%E6%9E%B6/"/>
      <url>/2017/12/30/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84wepy%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="小程序现状"><a href="#小程序现状" class="headerlink" title="小程序现状"></a>小程序现状</h2><p>微信小程序自发布到如今已经有半年多的时间了,凭借微信平台的强大影响力，越来越多企业加入小程序开发。 小程序于传统web页和APP比相比，有以下优势： </p><ol><li>小程序拥有更多的能力，包括定位、录音、文件、媒体、各种硬件能力等，想象空间更大 </li><li>运行在微信内部，体验更接近APP</li><li>在过度竞争的互联网行业中，获取一个有效APP用户的成本已经非常高了，小程序相比APP更加轻量、即用即走， 更容易获取用户</li></ol><h2 id="小程序问题"><a href="#小程序问题" class="headerlink" title="小程序问题"></a>小程序问题</h2><p>从<strong>开发角度</strong>来讲，，但同时也带来很多不便： </p><p>1、虽然小程序官方封装了很多常用组件给开发带来很多便利性,但在自定义组件复用性上十分薄弱,仅仅支持模板片段层面的复用,业务代码与交互事件都不支持。</p><p>2、小程序不支持SASS、LESS等预编译器,而小程序的<code>WXSS</code>语法在学习成本和功能性比不上我们日常开发的预编译器.</p><p>3、小程序支持部分ES6语法,不支持ES7、ES8的新语法.</p><p>4、在开发模式上,如果是<code>Angular</code>、<code>VUE</code>的开发者,在适应小程序的开发模式上,还需要时间适应.</p><h2 id="Wepy框架"><a href="#Wepy框架" class="headerlink" title="Wepy框架"></a>Wepy框架</h2><p>基于小程序存在的问题,腾讯的官方团队推出了<code>wepy</code>框架，该框架是腾讯内部基于小程序的开发框架，设计思路基本参考<strong>VUE</strong>，开发模式和编码风格上80%以上接近VUE，开发者可以以很小的成本从VUE开发切换成小程序开发。<br>WePY 是一款让小程序真正支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，<code>Promise</code>，<code>Async</code>、<code>await</code>的引入都是为了能让开发小程序项目变得更加简单，高效。</p><h3 id="Wepy框架的优势"><a href="#Wepy框架的优势" class="headerlink" title="Wepy框架的优势"></a>Wepy框架的优势</h3><p>1.<strong>新增属性,并针对原生API进行优化</strong><br>对现在API进行promise处理，同时修复一些现有API的缺陷，比如：<code>wx.request</code>并发问题等。</p><pre><code>// 官方wx.request({    url: &apos;xxx&apos;,    success: function (data) {        console.log(data);    }});// wepy 使用方式// request 接口从只接收Object变为可接收Stringwx.request(&apos;xxxx&apos;).then((d) =&gt; console.log(d));</code></pre><p>在同时并发10个request请求测试时：<br>不使用wepy:<br><img src="https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/2182004/20554651/5185f740-b198-11e6-88f8-45e359090dc3.png&amp;objectId=1190000007580866&amp;token=fd4bd72096cf29af2f7aa954056f459a" alt><br><img src="https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/2182004/20554886/c30e802a-b199-11e6-927d-08cd4e5ed0b0.png&amp;objectId=1190000007580866&amp;token=4cfef2840665f05dc9359b979eb2bb74" alt></p><p>使用wepy后：<br><img src="https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/2182004/20554663/65704c2e-b198-11e6-8277-abb77e0c7b3e.png&amp;objectId=1190000007580866&amp;token=eb5231dacbbab14ae42efeea2c4fee82" alt></p><h3 id="新增属性-vue移植"><a href="#新增属性-vue移植" class="headerlink" title="新增属性(vue移植)"></a>新增属性(vue移植)</h3><ul><li>computed 计算属性</li><li>watcher 监听器</li><li>props 传值</li><li>slot 组件内容分发插槽</li></ul><hr><p>2.<strong>单文件模式</strong><br>使得目录结构更加清晰 小程序官方目录结构要求app必须有三个文件<code>app.json</code>，<code>app.js</code>，<code>app.wxss</code>，页面有4个文件 <code>index.json</code>，<code>index.js</code>，<code>index.wxml</code>，<code>index.wxss</code>。而且文件必须同名。 所以使用wepy开发前后开发目录对比如下：</p><p>官方DEMO：</p><pre><code>project├── pages|   ├── index|   |   ├── index.json  index 页面配置|   |   ├── index.js    index 页面逻辑|   |   ├── index.wxml  index 页面结构|   |   └── index.wxss  index 页面样式表|   └── log|       ├── log.json    log 页面配置|       ├── log.wxml    log 页面逻辑|       ├── log.js      log 页面结构|       └── log.wxss    log 页面样式表├── app.js              小程序逻辑├── app.json            小程序公共设置└── app.wxss            小程序公共样式表</code></pre><p>使用wepy框架后目录结构：</p><pre><code>project└── src    ├── pages    |   ├── index.wpy    index 页面配置、结构、样式、逻辑    |   └── log.wpy      log 页面配置、结构、样式、逻辑    └──app.wpy           小程序配置项（全局样式配置、声明钩子等）</code></pre><p>3.<strong>真正的组件化开发</strong><br> 小程序虽然有 标签可以实现组件复用，但仅限于模板片段层面的复用，业务代码与交互事件 仍需在页面处理。无法实现组件化的松耦合与复用的效果.<br>但<strong>wepy</strong>能够真正实现组件化开发,这也是使用它的最大优势之一,而且<code>wepy</code>在使用上更靠近<code>vue</code>框架的书写风格,使用起来更得心应手。</p><pre><code>/ index.wpy&lt;template&gt;    &lt;view&gt;        &lt;panel&gt;            &lt;h1 slot=&quot;title&quot;&gt;&lt;/h1&gt;        &lt;/panel&gt;        &lt;counter1 :num=&quot;myNum&quot;&gt;&lt;/counter1&gt;        &lt;counter2 :num.sync=&quot;syncNum&quot;&gt;&lt;/counter2&gt;        &lt;list :item=&quot;items&quot;&gt;&lt;/list&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from &apos;wepy&apos;;import List from &apos;../components/list&apos;;import Panel from &apos;../components/panel&apos;;import Counter from &apos;../components/counter&apos;;export default class Index extends wepy.page {    config = {        &quot;navigationBarTitleText&quot;: &quot;test&quot;    };    components = {        panel: Panel,        counter1: Counter,        counter2: Counter,        list: List    };    data = {        myNum: 50,        syncNum: 100,        items: [1, 2, 3, 4]    }}&lt;/script&gt;</code></pre><h3 id="组件通信与交互"><a href="#组件通信与交互" class="headerlink" title="组件通信与交互"></a>组件通信与交互</h3><p><code>wepy.component</code>基类提供三个方法<code>$broadcast</code>，<code>$emit</code>，<code>$invoke</code>，因此任一页面或任一组件都可以调用上述三种方法实现通信与交互，如：<br>1.<strong>$broadcast</strong><br>$broadcast事件是由父组件发起，所有子组件都会收到此广播事件，除非事件被手动取消。事件广播的顺序为广度优先搜索顺序，如上图，如果Page_Index发起一个$broadcast事件，那么接收到事件的先后顺序为：A, B, C, D, E, F, G, H。如下图：</p><p><img src="https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/2182004/20554688/800089e6-b198-11e6-84c5-352d2d0e2f7e.png&amp;objectId=1190000007580866&amp;token=61f8192d48b7640ebef69ed8700726bf" alt></p><p>2.<strong>$emit</strong><br><code>$emit</code>与<code>$broadcast</code>正好相反，事件发起组件的父组件会依次接收到<code>$emit</code>事件，如上图，如果E发起一个$emit事件，那么接收到事件的先后顺序为：A, Page_Index。如下图：<br><img src="https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/2182004/20554704/9997932c-b198-11e6-9840-3edae2194f47.png&amp;objectId=1190000007580866&amp;token=707913104beb5c2ee310c64f22e37140" alt></p><p>3.<strong>$invoke</strong><br>$invoke是一个组件对另一个组件的直接调用，通过传入的组件路径找到相应组件，然后再调用其方法。</p><p>如果想在<code>Page_Index</code>中调用组件A的某个方法：</p><pre><code>this.$invoke(&apos;ComA&apos;, &apos;someMethod&apos;, &apos;someArgs&apos;);</code></pre><p>如果想在组件A中调用组件G的某个方法：</p><pre><code>this.$invoke(&apos;./../ComB/ComG&apos;, &apos;someMethod&apos;, &apos;someArgs&apos;);</code></pre><hr><p>4.<strong>支持加载外部NPM包</strong><br>小程序较大的缺陷是不支持<code>NPM</code>包，导致无法直接使用大量优秀的开源内容，<code>wepy</code>在编译过程当中，会递归 遍历代码中的<code>require</code>然后将对应依赖文件从<code>node_modules</code>当中拷贝出来，并且修改<code>require</code>为相对路径， 从而实现对外部NPM包的支持。</p><p><img src="https://cloud.githubusercontent.com/assets/2182004/20554645/482b0f64-b198-11e6-8d4e-70c92326004f.png" alt></p><p>5.默认使用<code>babel</code>编译，支持ES6/7的一些新特性，如promise，async/await等等</p><p>6.wepy支持使用<code>LESS</code>、<code>SASS</code>、<code>Styus</code>；</p><h3 id="wepy编译原理"><a href="#wepy编译原理" class="headerlink" title="wepy编译原理"></a>wepy编译原理</h3><p><img src="https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/2182004/20554671/70a797a0-b198-11e6-8355-b7c234713d0c.png&amp;objectId=1190000007580866&amp;token=a4993b9e79afe4e9af0e6866dfebdab9" alt></p><h3 id="weby快速起步"><a href="#weby快速起步" class="headerlink" title="weby快速起步"></a>weby快速起步</h3><p>weby配备了专门的构建工具脚手架<code>wepy-cli</code>协助开发,帮助快速起步</p><p>1.安装</p><pre><code>npm install wepy-cli -g</code></pre><p>2.脚手架</p><pre><code>wepy new myproject</code></pre><p>3.切换至项目目录</p><pre><code>cd myproject</code></pre><p>4.实时编译</p><pre><code>wepy build --watch</code></pre><p><code>wepy</code>作为一款优秀的微信小程序框架，可以帮我们大幅提高开发效率，在为数不多的小程序框架中一枝独秀，希望有更多的团队选择wepy。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的深拷贝与浅拷贝</title>
      <link href="/2017/12/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2017/12/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>在掌握深浅拷贝前,我们要知道,<code>JavaScript</code>的变量可以分为以下两种类型：</p><ul><li>基本类型<ul><li>undefined</li><li>null</li><li>number</li><li>string</li><li>boolean</li><li>symbol</li></ul></li></ul><blockquote><p>基本变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。</p></blockquote><ul><li>引用类型 Object、Function、Array</li></ul><blockquote><p>存放在堆内存中的对象，变量保存的是一个<strong>指针</strong>，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈内存中获得该对象的地址指针，然后再从堆内存中取得所需的数据。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>浅拷贝(shallowCopy)</strong>:<br>对于字符串类型，浅拷贝是对值的复制，对于对象来说，浅拷贝是对对象地址的复制，并不会开辟新的内存地址，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变;</p><p><strong>深拷贝(deepCopy)</strong>:<br>而深拷贝则是开辟新的内存地址，将原对象的各个属性逐个复制进去，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。</p><h2 id="深浅拷贝的实现"><a href="#深浅拷贝的实现" class="headerlink" title="深浅拷贝的实现"></a>深浅拷贝的实现</h2><h3 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h3><h4 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1.Object.assign"></a>1.Object.assign</h4><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象,这也是实现浅拷贝常用的方法之一.</p><pre><code>let obj1 = { a: 0 , b: { c: 0}};let obj2 = Object.assign({}, obj1);console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}</code></pre><h4 id="2-遍历对象属性赋值"><a href="#2-遍历对象属性赋值" class="headerlink" title="2.遍历对象属性赋值"></a>2.遍历对象属性赋值</h4><p>之前一直有一个错误实现深拷贝的想法，就是遍历一个对象的Key-Value对并一一复制给另一个对象便可以实现深拷贝。</p><p>但是是错误的，这个是浅拷贝(shallowCopy)</p><p>原因很简单，当Kry-Value对里value是Object的时候，复制过去便仍然是复制引用。</p><pre><code>let obj = {    a: 1,    b:{        c: 2,        d: 3    }}let obj2 = {}for(let item of Object.keys(obj)){    obj2[item] = obj[item]}obj2.b.d = 2; obj.b.d // 此时obj.b.d 变成了2,所以是浅拷贝</code></pre><hr><h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><h4 id="1-JSON对象的parse和stringify-最简单的"><a href="#1-JSON对象的parse和stringify-最简单的" class="headerlink" title="1.JSON对象的parse和stringify(最简单的)"></a>1.JSON对象的parse和stringify(最简单的)</h4><pre><code>let obj1 = { a: 0 , b: { c: 0}};let obj2 = JSON.parse(JSON.stringify(obj1));obj2.b.c = 3;console.log(obj2.b.c); // { a: 0 , b: { c: 3}};console.log(obj1.b.c); // { a: 0 , b: { c: 0}};</code></pre><p>该方法思路就是将一个对象转成json字符串，然后又将字符串转回对象。<br>能够处理<code>JSON</code>格式能表示的所有数据类型，但是无法拷贝对象里面的函数，正则表达式等，而且会丧失所有的<code>constructor</code>，也就是说，将是破坏整条<code>prototype</code>链。</p><h4 id="2-JQuery的extend"><a href="#2-JQuery的extend" class="headerlink" title="2.JQuery的extend()"></a>2.JQuery的extend()</h4><p>我们在 jQuery 中可以通过添加一个参数来实现递归extend。调用<code>$.extend(true, {}, ...)</code>就可以实现深复制啦，参考下面的例子：</p><pre><code>var x = {    a: 1,    b: { f: { g: 1 } },    c: [ 1, 2, 3 ]};var y = $.extend({}, x),          //shallow copy    z = $.extend(true, {}, x);    //deep copyy.b.f === x.b.f       // truez.b.f === x.b.f       // false</code></pre><h4 id="3-Lodash的深拷贝"><a href="#3-Lodash的深拷贝" class="headerlink" title="3.Lodash的深拷贝"></a>3.Lodash的深拷贝</h4><p><code>Lodash</code> 是一套基于<code>JavaScript</code>的工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 <code>ECMAScript</code> 尚未制定的规范，但同时被业界所认可的辅助函数。目前每天使用 <code>npm</code> 安装 <code>Lodash</code> 的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。<br><code>jQuery</code>无法深拷贝<code>JSON</code>对象以外的对象,但<code>Lodash</code>在源代码已经兼顾到许多ES6引入的新标准对象,所以在可用性上,比其他第三方库文件反馈更好,可用性更强.</p><pre><code>var objects = [{ &apos;a&apos;: 1 }, { &apos;b&apos;: 2 }];var deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]);// =&gt; false</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>基本类型变量存贮在栈内存区,存放在堆内存中的对象，变量保存的是一个指针。</li><li>直接遍历对象一一复制是浅拷贝(shallowCopy)</li><li>深拷贝即是在堆内存区拷贝出一个对象来。</li><li>深拷贝当然更占内存，请一定要针对不同的场景做不同的拷贝处理。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈现在的移动端页面调试</title>
      <link href="/2017/12/19/%E8%B0%88%E8%B0%88%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%AF%95/"/>
      <url>/2017/12/19/%E8%B0%88%E8%B0%88%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>通常我们在日常开发手机版网页的时候，都是通过PC浏览器的移动设备模式来模拟移动设备访问网页,但总会出现以下的问题:</p><p>开发时，在自己电脑上运行得好好的，在真机上打开就挂了，但是手机上又看不到错误的log信息；</p><p>作为开发者，我们的诉求很简单：有没有快捷的工具可以让我们在真机运行网页的时候可以看到log信息。</p><p>答案是肯定的。<br>接下来就给大家介绍一下这些工具:</p><h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p>由<strong>鹅厂</strong>开发的一个轻量、可拓展、针对手机网页的前端开发者调试面板。<img src="https://github.com/Tencent/vConsole" alt="vConsole"></p><blockquote><p>特性：</p></blockquote><ul><li>使用简单</li><li>查看 console 日志,包括报错、Objet/Array等信息</li><li>查看网络请求</li><li>手动执行 JS 命令行</li><li>自定义插件,可查看HTML、CSS、JS源码</li></ul><h3 id="上手使用"><a href="#上手使用" class="headerlink" title="上手使用"></a>上手使用</h3><blockquote><p>1.使用 npm 安装：</p></blockquote><pre><code>npm install vconsole</code></pre><blockquote><p>2.直接引入:</p></blockquote><pre><code>&lt;script src=&quot;path/to/vconsole.min.js&quot;&gt;&lt;/script&gt;</code></pre><blockquote><p>3.初始化 &amp; 配置</p></blockquote><pre><code>//引入后, 需要手动初始化 vConsole：var vConsole = new VConsole();</code></pre><blockquote><p>4.打印日志</p></blockquote><pre><code>console.log(&apos;foo&apos;);   // 白底黑字console.info(&apos;bar&apos;);  // 白底紫字console.debug(&apos;oh&apos;);  // 白底黄字console.warn(&apos;foo&apos;);  // 黄底黄字console.error(&apos;bar&apos;); // 红底红字</code></pre><blockquote><p>5.打印Object/Array</p></blockquote><pre><code>var obj = {};obj.foo = &apos;bar&apos;;console.log(obj);/*Object{  foo: &quot;bar&quot;} */</code></pre><p>使用<code>vConsole</code>可以很方便的log我们想要的信息,只是需要引入一个库文件,而且不支持代码断点,以及不支持查看元素的样式是写在<code>css</code>第几行，也不支持显示在哪个文件，于是还有一种更加好的方案.</p><hr><h2 id="Chrome远程调试-Remote-Debugging"><a href="#Chrome远程调试-Remote-Debugging" class="headerlink" title="Chrome远程调试(Remote Debugging)"></a>Chrome远程调试(Remote Debugging)</h2><p><img src="http://images.cnitblog.com/blog/494920/201411/130923544443367.jpg" alt><br><code>Chrome</code>浏览器是可以通过USB连接移动设备进行远程Web页面调试的,上图的左边是pc端的chrome浏览器，右边是手机上的<code>Chrome</code> 然后可以看到当鼠标移动到某个<code>div</code>上时 手机上的这个区域高亮显示 跟pc上调试某段代码效果一样 你可以修改代码 并直接在手机上反馈修改结果</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在移动调试前我们需要以下准备工作:</p><ol><li>pc端安装最新的chrome</li><li>(Android设备)手机端安装最新的chrome </li><li>USB连接线</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><strong>USB设置</strong> 在你的手机里打开”设置”-&gt;”开发人员工具”-&gt;”USB调试” 打开USB调试。 因为Android手机型号众多 很多人找不到”USB调试这个选项在哪” 而且大多数手机”开发者选项”默认是影藏的，你需要看下自己的手机说明然后将手机调到”开发者模式” 就可以找到 “USB调试了” </p><p>假设你已经将手机设置为”USB调试”打开的状态 将手机连接到电脑 手机会弹出是否链接 点击确定,并安装好驱动,这是<strong>关键</strong>.</p><p><img src="http://img.blog.csdn.net/20150108192728031" alt></p><p>打开电脑的chrome 在地址栏输入 <code>chrome://inspect</code>  选中 <code>Discover USB devices</code>可以检测到你的设备 </p><p><img src="https://i.imgur.com/O5GwQwx.png" alt></p><p>在移动设备上打开chrome,并访问要调试的网址<br><img src="https://i.imgur.com/yPYDJ1L.jpg" alt></p><p>点击<code>inspect</code> 如下图 就看到了文章开始一样的效果 此时就是可以审查手机页面上的元素了<br><img src="https://i.imgur.com/h3DZ6tJ.jpg" alt></p><p>使用Chrome远程调试的方式可以更加全面的调试代码和审查元素,但有不好的地方就是只支持安卓设备,目前是不支持IOS苹果设备的.<br>不过这个也不是问题,IOS 的话，可以使用<code>iphone</code> 数据线链接 <code>Mac</code>，打开 <code>Safari</code> 就可以直接使用 <code>Mac</code> 的 <code>Safari</code> 调试工具了,跟chrome的方法类似。</p><h3 id="调试iOS上的Safari"><a href="#调试iOS上的Safari" class="headerlink" title="调试iOS上的Safari"></a>调试iOS上的Safari</h3><ol><li>在iOS设备上打开允许调试：设置→Safari→高级→打开”web检查器“</li><li>在MAC上打开Safari的开发菜单：顶部菜单栏“Safari”→偏好设置→高级→打开”在菜单栏中显示“开发”菜单</li><li>在iOS设备上的Safari浏览器中打开要调试的页面，然后切换到MAC的Safari，在顶部菜单栏选择“开发”→找到你的iOS设备名称→右边二级菜单选择需要调试的对应标签页，即可开始远程调试<br><img src="https://i.imgur.com/I2IlAA7.png" alt></li></ol><p>如果没有iOS设备，也可以在Xcode中模拟一台，点击顶部“Xcode”→“Open Developer Tool”→“iOS Simulator”即可打开一个iOS设备的模拟器，并且模拟器里面Safari打开的页面，也是能通过上个步骤中MAC上的Safari调试。<br><img src="https://i.imgur.com/bXzuEH6.jpg" alt></p><h3 id="UC浏览器开发版"><a href="#UC浏览器开发版" class="headerlink" title="UC浏览器开发版"></a>UC浏览器开发版</h3><p>同时UC也提供了真机调试的版本<br><a href="http://www.uc.cn/business/developer/" title="UC浏览器开发版" target="_blank" rel="noopener">http://www.uc.cn/business/developer/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端包管理器的发展</title>
      <link href="/2017/12/08/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%8F%91%E5%B1%95/"/>
      <url>/2017/12/08/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在开发时，会用到很多开发者写的第三方库。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。<br>于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到一个包管理器的平台上，如果要使用，直接通过包管理器安装就可以直接用，不用管代码存在哪，应该从哪下载。</p><p>因此使用包管理器主要基于以下几个原因：</p><ol><li>方便的寻找和下载你需要的依赖库，并将它们整合到项目中，例如<code>jQuery</code>,<code>Angular</code>等。</li><li>方便的下载指定版本的依赖库（免除去网络上搜索和下载）</li><li><strong>解决第三方库之间的依赖关系</strong></li></ol><h2 id="Bower"><a href="#Bower" class="headerlink" title="Bower"></a>Bower</h2><p>由<code>twitter</code>推出的包管理工具。基于nodejs的模块化思想,把功能分散到各个模块中，让模块和模块之间存在联系,通过 Bower 来管理模块间的这种联系。它的特点是对包结构没有强制规范，即依赖扁平。</p><p>但<code>Bower</code>本身不存储模块文件本身，也不保存模块的版本信息。模块的发布者通过注册（register）的方式，将模块的可访问的公开的git地址记录在bower的数据库中。而所有的版本都是通过模块发布者自己控制代码库的tag来决定。</p><p><code>Bower</code>在安装流程基本上可以简单认为是将注册的git地址中的特定tag clone一份到你本地的bower_components 目录中。</p><p><code>Bower</code>本身也存在很多问题,也是导致频临淘汰的原因:</p><ol><li>数据源的问题,<code>Bower</code> 直接取 <code>github</code> 而缺少像 <code>npm</code> 那样的 <code>registry</code>，导致一个问题，<code>github上</code>放的是源码，和部署所需是不同的，这导致使用上的问题，对于开发者而言,还需要专门开个分支整理出一个适合使用者的源码.</li><li>缺乏构建工具</li><li>源数据问题</li></ol><hr><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p><code>npm</code>(node package manager)有两层含义。一层含义是Node的开放式模块登记平台和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。</p><p><code>npm</code>不需要单独安装。在安装Node的时候，会连带一起安装npm。<br>同时也是目前开发者中使用率最高的包管理器<br>但是，Node附带的npm可能不是最新版本，最好用下面的命令，更新到最新版本。</p><p><code>NPM</code>较之<code>Bower</code>,具有一个独立的服务器网站用来存放开发者的库文件,且在处理库与库之间的依赖关系上更强.</p><h3 id="CNPM"><a href="#CNPM" class="headerlink" title="CNPM"></a>CNPM</h3><p>因为<code>npm</code>的服务器是在国外,所以被墙是经常的,这是就要介绍一下比较良心的<code>cnpm</code>了.<br>CNPM即是<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝镜像源</a>,这是一个完整  <a href="http://npmjs.org" target="_blank" rel="noopener">npmjs.org</a> 镜像，用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p><p>使用<code>cnpm</code>后,<code>install</code>的速度可比<code>cnpm</code>快得多了。</p><hr><h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><p>facebook发布的新一代包管理工具，旨在解决以往使用npm作为包管理会遇到的一些问题。从其官方介绍可以看到其重点强调的3个点：快、可靠、安全。</p><h3 id="yarn的优势"><a href="#yarn的优势" class="headerlink" title="yarn的优势"></a>yarn的优势</h3><p>相比于<code>Node</code>的亲儿子<code>npm</code>来说，<code>yarn</code>有以下优势:</p><p>1、安装模块速度更快<br><img src="http://7tszky.com1.z0.glb.clouddn.com/FifXFXX6rNLMtwA5xuvB85DzDL0M" alt></p><p>2、支持离线模式(只要你安装过此模块，第二次安装就会从缓存文件中直接复制过来)<br><code>yarn</code>会有一个缓存目录，会缓存以前安装过的软件包，再次安装时就不必从网络下载了，大大加速安装速度。<br>这一点很重要，<code>npm</code> 饱受诟病的一点就是，每次安装依赖，都需要从网络下载一大堆东西，而且是全部重新下载，工程多的时候比较烦人。</p><p>3、依赖关系确定性.<br>在每一台机器上针对同一个工程安装依赖时，生成的依赖关系顺序和版本是一致的。<br>之前 npm 在这里有一个处理得不好的地方 。举例来说，我写的工程依赖 A, B, C 三个库，我在编写 package.json 的时候，给 A, B, C 都指定了版本号。但是 A 库可能又依赖 D, E, F 库，D 库又依赖 G, H 库。这么多关联依赖关系中，<strong>很可能某个库在指定依赖时，没有指定版本号</strong>。<br>于是，这就导致了一个问题。如果我在另一台机器上对同样的工程安装依赖，或者把这台机器工程下的 node_modules 目录删除来重新安装依赖。由于关联依赖中，没有指定版本号的库，发生了版本更新，就会导致再次安装的依赖，其中具体某些软件包的版本是不一致的。在这种情况下，你会发现原来能够正常运行的程序，忽然变得不能工作或一堆 BUG.</p><p>而<code>yarn</code>在解析package.json文件时，会对其每个依赖包进行遍历分析生成yarn.lock文件。该文件描述了项目中每个包以及每个包中所依赖的包的版本信息。</p><p>4.迁移方便</p><h2 id="目前npm的项目迁移至yarn-基本是无痛迁移-可以很方便的就切换"><a href="#目前npm的项目迁移至yarn-基本是无痛迁移-可以很方便的就切换" class="headerlink" title="目前npm的项目迁移至yarn,基本是无痛迁移,可以很方便的就切换."></a>目前<code>npm</code>的项目迁移至<code>yarn</code>,基本是无痛迁移,可以很方便的就切换.</h2><h3 id="yarn-amp-npm-常用命令比较"><a href="#yarn-amp-npm-常用命令比较" class="headerlink" title="yarn &amp; npm 常用命令比较"></a>yarn &amp; npm 常用命令比较</h3><ul><li>npm install === yarn / yarn install</li><li>npm install xxx —save === yarn add xxx</li><li>npm uninstall xxx —save === yarn remove xxx</li><li>npm install xxx —save-dev === yarn add xxx —dev</li><li>npm update === yarn upgrade</li><li>npm install xxx -g === yarn global add xxx<br>当然，在比较选择<code>yarn</code>与<code>npm</code>时，速度也是一个很重要的衡量指标。</li></ul><hr><h3 id="Yarn总结"><a href="#Yarn总结" class="headerlink" title="Yarn总结"></a>Yarn总结</h3><p>yarn 相比 npm 最直观优势就是快<br>目前项目在基本可以无痛迁移使用。<br>yarn 目前并不是非常稳定，不少反馈script run以及下载包有问题。<br>lock功能具有双面性，是否锁定版本需要看具体情况而定</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈我们日常接触的APP</title>
      <link href="/2017/11/28/%E8%B0%88%E8%B0%88%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E6%8E%A5%E8%A7%A6%E7%9A%84APP/"/>
      <url>/2017/11/28/%E8%B0%88%E8%B0%88%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E6%8E%A5%E8%A7%A6%E7%9A%84APP/</url>
      
        <content type="html"><![CDATA[<h2 id="APP现状分析"><a href="#APP现状分析" class="headerlink" title="APP现状分析"></a>APP现状分析</h2><p>近年来随着移动设备类型的变多，操作系统的变多，用户需求的增加，开发App的方案已经变得越来越多了。下面就由我来详细罗列一下各种开发APP的方式.</p><h2 id="APP开发方案"><a href="#APP开发方案" class="headerlink" title="APP开发方案"></a>APP开发方案</h2><p><img src="http://image.uisdc.com/wp-content/uploads/2014/12/texingfenxi.png" alt></p><h3 id="Web-App"><a href="#Web-App" class="headerlink" title="Web App"></a>Web App</h3><p><strong>Web App</strong>指采用Html5语言写出的App,无须下载安装。类似于现在所说的轻应用。生存在浏览器中的应用，基本上可以说是触屏版的网页应用。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ol><li>开发成本低;</li><li>更新快;</li><li>更新无需通知用户，不需要手动升级;</li><li>能够跨多个平台和终端;</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>性能缺陷,体验较差;</li><li>无法获取系统级别的通知，提醒，动效等等;</li><li>用户留存率低</li><li>设计受限制诸多</li></ol><hr><h3 id="Native-APP"><a href="#Native-APP" class="headerlink" title="Native APP"></a>Native APP</h3><p>Native APP 指的是原生程序，一般依托于操作系统，有很强的交互，是一个完整的App，可拓展性强。需要用户下载安装使用。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>打造完美的用户体验</li><li>性能稳定</li><li>操作速度快，上手流畅</li><li>访问本地资源（通讯录，相册）</li><li>设计出色的动效，转场，</li><li>拥有系统级别的贴心通知或提醒</li><li>用户留存率高</li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>分发成本高（不同平台有不同的开发语言和界面适配）</li><li>维护成本高（例如一款App已更新至V5版本，但仍有用户在使用V2， V3， V4版本，需要更多的开发人员维护之前的版本）</li><li>更新缓慢，根据不同平台，提交–审核–上线 等等不同的流程，需要经过的流程较复杂</li></ol><hr><h3 id="Hybrid-APP"><a href="#Hybrid-APP" class="headerlink" title="Hybrid APP"></a>Hybrid APP</h3><p>今天我们着重讲的开发方案是Hybrid APP(混合APP)。<br>Hybrid App主要以JS+Native两者相互调用为主，从开发层面实现“一次开发，多处运行”的机制，成为真正适合跨平台的开发。Hybrid App兼具了Native App良好用户体验的优势，也兼具了Web App使用HTML5跨平台开发低成本的优势。</p><p>基于以上优势,目前已经有绝大多数的中大型APP,已经不会是纯粹的Native APP,转而被Hybrid App所取代，比如淘宝、天猫、京东、爱奇艺、微信等知名移动应用，都是采用Hybrid App开发模式。</p><h3 id="Hybrid-APP类型"><a href="#Hybrid-APP类型" class="headerlink" title="Hybrid APP类型"></a>Hybrid APP类型</h3><h4 id="方案一：Web主体型"><a href="#方案一：Web主体型" class="headerlink" title="方案一：Web主体型"></a>方案一：Web主体型</h4><p>即移动应用的主体是Web View，主要以网页语言编写，穿插Native功能的Hybrid App开发类型。这种类型开发的移动应用体验相对而言存在缺陷，但整体开发难度大幅降低，并且基本可以实现跨平台。<br>使用Ionic、Weex、NativeScript、React Native之类的框架。</p><p><img src="https://i.imgur.com/KPRqQyB.png" alt></p><p>优点：</p><p>全Web开发，一定程度上有利于Web前端技术人员快速地构建页面样式,且跨平台,极大程度降低开发APP成本.<br>便于调试，开发的时候可以通过浏览器的方式进行调试，工具丰富。</p><p>缺点:</p><ol><li>兼容性是极大的问题,特别是在Android机器上,因为国产的系统花样繁多,且底层代码大多被都修改,导致在即便在Android机器上,显示也有很多差异。</li><li>在业务复杂的界面,如list页,极容易造成机器内存暴涨,极不稳定。</li><li>基于以上两点,web主体型并不是适合开发中大型业务复杂的APP.</li></ol><h4 id="方案二-Native主体型"><a href="#方案二-Native主体型" class="headerlink" title="方案二:Native主体型"></a>方案二:Native主体型</h4><p>在开发原生应用的基础上，嵌入WebView控件但是整体的架构仍然使用原生应用提供，一般这样的开发是由Native开发人员主导,Web前端开发人员为辅。Native开发人员会写好基本的架构以及API让Web开发人员开发界面以及大部分的渲染。保证到交互设计，以及开发都有一个比较折中的效果出来，优化得好也会有很棒的效果。但不具备跨平台的功能。</p><p>优点：</p><p>这无疑是最稳定的Hybrid App开发方式了，交互层的效率上由Native的东西解决了，而且架构上基本就是在App内写网页，连App Store都是采用了该种方案；<br>开发时分工非常明确，底层的由iOS开发人员处理，上层的由Web前端开发人员处理；<br>有效的在线参数配置方式，以便于及时在线替换界面；</p><p>缺点：</p><p>相对于native APP团队而言,团队还需要多一个web前端工程师,仅仅只是分担了IOS/Android的工作量,并没有降低多少开发成本.<br>还是运行效率，要权衡好多少界面采用Web来渲染，毕竟WebView的效率会相对降低，以前Facebook就是因为Web的渲染效率低下，把整个应用改为原生的解决方案。当然这里面可以通过优化来解决。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MPA和SPA,你选哪一个</title>
      <link href="/2017/11/23/MPA%E5%92%8CSPA-%E4%BD%A0%E9%80%89%E5%93%AA%E4%B8%80%E4%B8%AA/"/>
      <url>/2017/11/23/MPA%E5%92%8CSPA-%E4%BD%A0%E9%80%89%E5%93%AA%E4%B8%80%E4%B8%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>旧的桌面应用程序被Web应用程序推到了极点。基于Web的应用程序使用起来非常方便，可以从多个设备访问，并且易于升级。对移动友好的复杂应用程序的需求正在上升。熟悉Web应用程序开发的您必须了解两种主要的Web设计类型：单页应用程序（SPA）和多页面应用程序（MPA）。</p><h2 id="多页面应用程序-MultiPage-Application，MPA"><a href="#多页面应用程序-MultiPage-Application，MPA" class="headerlink" title="多页面应用程序(MultiPage Application，MPA)"></a>多页面应用程序(MultiPage Application，MPA)</h2><p><img src="https://user-gold-cdn.xitu.io/2017/11/17/15fc93684b5f10e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br><code>MPA</code>的工作遵循传统模式，即每次更改都会重新提交，或者从服务器显示为新的页面。鉴于这些应用程序的性质，它们的大小以适应其功能。内容的巨大增加给应用程序提供了多层UI的复杂性。侵入的复杂性是在21世纪初引入的<code>AJAX</code>（异步JavaScript和XML），这使得仅仅刷新网站的一部分而不是重新提交整个页面成为可能。尽管它极大地改善了用户体验，但却为页面增添了一层复杂性。与<code>SPA</code>的直接方法相比，<code>MPA</code>的发展是复杂的。</p><h3 id="MPA的优点"><a href="#MPA的优点" class="headerlink" title="MPA的优点"></a>MPA的优点</h3><ol><li><code>MPA</code>方法最适合那些设计为视觉地图的网站。多级菜单导航是传统<code>MPA</code>的核心。</li><li>开发成本和学习门槛较低,易于上手。</li><li>SEO搜索引擎优化管理是有效的，因为不同的关键字可以优化每个应用程序的一个关键字。</li></ol><h3 id="MPA的弱点"><a href="#MPA的弱点" class="headerlink" title="MPA的弱点"></a>MPA的弱点</h3><ol><li><code>MPA</code>资源不共用，每个页面都需要加载,这就意味着大部分页面的部分代码和资源都是重复加载的.</li><li><strong>用户体验</strong>较差,多页面切换会造成整页刷新,加载缓慢,流畅度也不足,且无法实现转场动画。</li><li>传统前后端开发模式,非前后端分离,导致不够高效。</li></ol><h2 id="单页应用程序-SinglePage-Web-Application，SPA"><a href="#单页应用程序-SinglePage-Web-Application，SPA" class="headerlink" title="单页应用程序(SinglePage Web Application，SPA)"></a>单页应用程序(SinglePage Web Application，SPA)</h2><p><img src="https://user-gold-cdn.xitu.io/2017/11/17/15fc93562b418a6e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>简单点说,<code>SPA</code>就是只有一个Web页面的应用，单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。</p><h3 id="怎么实现无刷新的呢"><a href="#怎么实现无刷新的呢" class="headerlink" title="怎么实现无刷新的呢?"></a>怎么实现无刷新的呢?</h3><p>那就是History API.<br><code>History API</code>是HTML5 的历史记录 API。这套 API 提供一种「人为操纵」浏览器历史记录的方法,可以实现无刷新更改地址栏链接，配合 AJAX 可以做到无刷新跳转。<br>简单来说：假设当前页面为xposean.xin/，那么执行下面的 JavaScript 语句：</p><pre><code>window.history.pushState(null, null, &quot;/profile/&quot;);</code></pre><p>之后，地址栏的地址就会变成xposean.xin/profile/，但同时浏览器不会刷新页面，甚至不会检测目标页面是否存在。</p><h4 id="pushState方法"><a href="#pushState方法" class="headerlink" title="pushState方法"></a>pushState方法</h4><p>浏览器历史记录可以看作一个「栈」。栈是一种后进先出的结构，可以把它想象成一摞盘子，用户每点开一个新网页，都会在上面加一个新盘子，叫「入栈」。用户每次点击「后退」按钮都会取走最上面的那个盘子，叫做「出栈」。而每次浏览器显示的自然是最顶端的盘子的内容。</p><p>执行pushState函数之后，会往浏览器的历史记录中添加一条新记录，同时改变地址栏的地址内容。它可以接收三个参数，按顺序分别为：</p><ol><li>一个对象或者字符串，用于描述新记录的一些特性。这个参数会被一并添加到历史记录中，以供以后使用。这个参数是开发者根据自己的需要自由给出的。</li><li>一个字符串，代表新页面的标题。当前基本上所有浏览器都会忽略这个参数。</li><li><p>一个字符串，代表新页面的相对地址。</p><pre><code>var state = {    id: 2,    name: &quot;profile&quot;};window.history.pushState(state, &quot;My Profile&quot;, &quot;/profile/&quot;);</code></pre></li></ol><h4 id="replaceState-方法"><a href="#replaceState-方法" class="headerlink" title="replaceState 方法"></a>replaceState 方法</h4><p>有时，你希望不添加一个新记录，而是替换当前的记录（比如对网站的 loading-page），则可以使用replaceState方法。这个方法和pushState的参数完全一样。</p><h3 id="SPA的优点"><a href="#SPA的优点" class="headerlink" title="SPA的优点"></a>SPA的优点</h3><ol><li>分离前后端关注点，前端负责view，后端负责model，各司其职； </li><li>服务器只接口提供数据，不用展示逻辑和页面合成，提高性能； </li><li>同一套后端程序代码，不用修改兼容Web界面、手机； </li><li>用户体验好、快，内容的改变不需要重新加载整个页面 </li><li>可以缓存较多数据，减少服务器压力 </li><li>单页应用像网络一样，几乎随处可以访问—不像大多数的桌面应用，用户可以通过任务网络连接和适当的浏览器访问单页应用。如今，这一名单包括智能手机、平板电脑、电视、笔记本电脑和台式计算机。 </li></ol><h3 id="SPA的缺点："><a href="#SPA的缺点：" class="headerlink" title="SPA的缺点："></a>SPA的缺点：</h3><ol><li>SEO问题</li><li>首次加载时间较长。 </li><li>页面复杂度提高很多，复杂逻辑难度成倍,意味着开发成本和学习成本的提高。</li></ol><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文部分内容出处为<a href="https://mouthmedia.com/blog/mpa-or-spa-which-one-should-you-choose/" target="_blank" rel="noopener">MPA OR SPA? WHICH ONE SHOULD YOU CHOOSE?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的高级运用之节流与防抖</title>
      <link href="/2017/11/17/JavaScript%E7%9A%84%E9%AB%98%E7%BA%A7%E8%BF%90%E7%94%A8%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
      <url>/2017/11/17/JavaScript%E7%9A%84%E9%AB%98%E7%BA%A7%E8%BF%90%E7%94%A8%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<h2 id="概念与目的"><a href="#概念与目的" class="headerlink" title="概念与目的"></a>概念与目的</h2><p>首先还是得先来讲讲概念,<strong>节流</strong>和<strong>防抖</strong>的目的都十分的简单,就是为了性能优化而出现的,目的是为了解决一些短时间内连续执行导致性能不佳或者内存消耗巨大的情况。<br>这类事件有:<code>scroll</code> <code>keyup</code> <code>mousemove</code> <code>resize</code>事件等，短时间内会不断的触发，在性能上消耗是非常大的，尤其是一些改变DOM结构的操作；<br>例如我们的<code>scroll</code>事件,当使用触控板，滚动滚轮，或者拖拽滚动条的时候，一秒就可以触发 30 次事件。经测试，在移动设备上轻轻滚动一下，一秒可以触发 100 次之多。这么高的执行频率是我们无法忍受的。<br>所以,在这些高频率触发的事件中,<code>节流</code>[throttle]与<code>防抖</code>[debounce]十分有必要了,它们非常相似，都是让上述这类事件在规定的事件从不断的去触发更改成为规定的时间内触发多少次；</p><h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流[throttle]"></a>节流[throttle]</h2><p>我们的所谓节流,就是需要事件按照我们规定的时间间隔内执行,换成函数来说，使用setTimeout方法，给定两个时间，后面的时间减去前面的时间，得到时间间隔,这个时间到达我们给定的时间就去触发一次这个事件.</p><p>来看看我们的代码,以<code>scroll</code>:</p><pre><code>/** 先给定DOM结构;**/&lt;div class=&quot;scroll-box&quot;&gt;    &lt;div class=&quot;scroll-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;/**主要看js,为了简单我用JQ去写了**/&lt;script&gt;    $(function(){        var scrollBox = $(&apos;.scroll-box&apos;);        //调用throttle函数，传入相应的方法和规定的时间;        var thro = throttle(throFun,300);        //触发事件;        scrollBox.on(&apos;scroll&apos; , function(){            //调用执行函数;            thro();        })        // 节流函数;            function throttle(method,time){            var timer = null;            var startTime = new Date();            return function(){                var context = this;                var endTime = new Date();                var resTime = endTime - startTime;                //判断大于等于我们给的时间采取执行函数;                if(resTime &gt;= time){                    method.call(context);//success                    //执行完函数之后重置初始时间，等于最后一次触发的时间                    startTime = endTime;                }            }        }        //执行函数        function throFun(){            console.log(&apos;success&apos;);        }    })&lt;/script&gt;</code></pre><p>通过函数,我们其实也清晰的明白了,节流的原理,首先给给定一个间隔时间值,然后我们的节流函数就会通过比对上一次的时间和当前时间,超过或者等于这个时间才触发,反之,则不执行.<br>以上的代码就能实现,300ms内触发一次。</p><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖[debounce]"></a>防抖[debounce]</h2><p>代码之前，我们先清楚一下防抖的概念，不知道大家有没有做过电脑端两边悬浮广告窗口的这么一个东西，当我们拖动滚动条的时候，两边的广告窗口会因为滚动条的拖动，而不断的尝试着去居于中间，然后你就会看到这两个窗口，不停的抖啊抖；<br>一般这种就叫抖动了，我们要做的就是防止这种抖动，称为防抖[debounce]；<br>比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。<br>那这里防抖思想就是当我们拖动完成之后，两边的窗口位置再重新去计算，这样，就会显得很平滑，看着很舒服了，最主要的操作DOM结构的次数就大大减少了；<br>优化了页面性能，降低了内存消耗，不然你像IE这种比较老点版本的浏览器，说不定就直接给你蹦了<br>用书面一点的说法就是，在某个事件没有结束之前，函数不会执行，当结束之后，我们给定延时时间，然他在给定的延时时间之后再去执行这个函数，这就是防抖函数；<br>来看代码：</p><pre><code>/** 先给定DOM结构;**/&lt;div class=&quot;scroll-box&quot;&gt;    &lt;div class=&quot;scroll-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;/**主要看js,为了简单我用JQ去写了**/&lt;script&gt;    $(function(){        var scrollBox = $(&apos;.scroll-box&apos;);        //调用throttle函数，传入相应的方法和规定的时间;        var debo = debounce(debounceFun,300);        //触发事件;        scrollBox.on(&apos;scroll&apos; , function(){            //调用执行函数;            debo();        })        // 防抖函数;            function debounce(method,time){            var timer = null ;            return function(){                var context = this;                //在函数执行的时候先清除timer定时器;                clearTimeout(timer);                timer = setTimeout(function(){                    method.call(context);  //success                },time);            }        }        function debounceFun(){            console.log(&apos;success&apos;);        }    })&lt;/script&gt;</code></pre><p>思路就是在函数执行之前，我们先清除定时器，如果函数一直执行，就会不断的去清除定时器中的方法，直到我们操作结束之后，函数才会执行；</p><p>其实书写的方式有很多，主要还是思路的问题，大家写的多了，自然就知道了；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>表格布局display:table的妙用</title>
      <link href="/2017/11/12/%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80display-table%E7%9A%84%E5%A6%99%E7%94%A8/"/>
      <url>/2017/11/12/%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80display-table%E7%9A%84%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>今天给大家讲一下,CSS2提供的一个布局,<code>display:table;</code>,虽然在CSS3提供了两个全新的布局,Flex和Grid布局,但却存在这样或那样的兼容性问题,其次我们有时候因为table的语义化和SEO问题,不想使用<code>table</code>标签,却需要实现<code>table</code>标签的表格布局,就能用到<code>CSS2</code>提供的这个属性.</p><p>接下来看看关于table的display可选值：</p><ul><li><code>table</code>：指定对象作为块元素级的表格，相当于html标签<code>&lt;table&gt;</code></li><li><code>inline-table</code>：指定对象作为内联元素级的表格，相当于html标签<code>&lt;table&gt;</code></li><li><code>table-caption</code>：指定对象作为表格标题，相当于html标签<code>&lt;caption&gt;</code></li><li><code>table-cell</code>：指定对象作为表格单元格，相当于html标签<code>&lt;td&gt;</code></li><li><code>table-row</code>：指定对象作为表格行，相当于html标签<code>&lt;tr&gt;</code></li><li><code>table-row-group</code>：指定对象作为表格行组，相当于html标签<code>&lt;tbody&gt;</code></li><li><code>table-column</code>：指定对象作为表格列，相当于html标签<code>&lt;col&gt;</code></li><li><code>table-column-group</code>：指定对象作为表格列组显示，相当于html标签<code>&lt;colgroup&gt;</code></li><li><code>table-header-group</code>：指定对象作为表格标题组，相当于html标签<code>&lt;thead&gt;</code></li><li><code>table-footer-group</code>：指定对象作为表格脚注组，相当于html标签<code>&lt;tfoot&gt;</code></li></ul><p>还有一些协助属性：</p><ul><li><code>border-collpase</code>：用来决定表格的边框是分开的还是合并的。在分隔模式下，相邻的单元格都拥有独立的边框。在合并模式下，相邻单元格共享边框。</li><li><code>border-spacing</code>： 规定相邻单元格边框之间的距离（只适用于 边框分离模式 ）。相当于 HTML 中的 <code>cellspacing</code> 属性，但是第二个可选的值可以用来设置不同于水平间距的垂直间距。</li><li><code>table-layout</code>：定义了用于布局表格单元格，行和列的算法。(auto：表格及单元格的宽度取决于其包含的内容。fixed：表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。)</li><li><code>vertical-align</code>：用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。</li></ul><h2 id="使用display-table的好处"><a href="#使用display-table的好处" class="headerlink" title="使用display:table的好处"></a>使用<code>display:table</code>的好处</h2><p>除了在兼容性更好和语义化程度更强之外,表格布局也继承了<code>table</code>标签的布局优势;</p><h3 id="更简单的栅格布局"><a href="#更简单的栅格布局" class="headerlink" title="更简单的栅格布局"></a>更简单的栅格布局</h3><pre><code>&lt;style&gt;  .box{    border:1px solid #dedede;    display:table;    height: 300px;    width: 100%;  }    .box .item{    border-right:1px solid #ccc;    display:table-cell;  }&lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;item&quot;&gt;AA&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;BB&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;CC&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p><img src="https://i.imgur.com/Wwt9pcI.png" alt><br>很轻松的就能够实现,一行多列的布局,而且自动根据<code>.item</code>元素个数计算<code>.item</code>的宽度,<br>比原来通过浮动并设置百分比方便多了.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>详解CSS中的函数</title>
      <link href="/2017/11/05/%E8%AF%A6%E8%A7%A3CSS%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2017/11/05/%E8%AF%A6%E8%A7%A3CSS%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>首先我们很好奇,css这一门都不能算的上是正常的编程语言,竟然还有函数这一回事,其实是有的,只是我们因为日常很少用到,所以一直没有听闻罢了。</p><h2 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h2><p><code>calc()</code>从字面我们可以把他理解为一个函数<code>function</code>。其实calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，用于动态计算长度值。<br>通常會用來做數值的運算，尤其是針對於長寬等等，而他最特別的是運算的數值”不需要”相同單位.</p><h3 id="calc-语法"><a href="#calc-语法" class="headerlink" title="calc()语法"></a>calc()语法</h3><p>calc()语法非常简单，就像我们小时候学加 （+）、减（-）、乘（*）、除（/）一样，使用数学表达式来表示：</p><pre><code>width: calc(四则运算);</code></pre><h3 id="calc-的运算规则"><a href="#calc-的运算规则" class="headerlink" title="calc()的运算规则"></a>calc()的运算规则</h3><p>calc()使用通用的数学运算规则，但是也提供更智能的功能：</p><p>使用“+”、“-”、“<em>” 和 “/”四则运算；<br>可以使用百分比、px、em、rem等单位；<br>可以混合使用各种单位进行计算；<br>表达式中有“+”和“-”时，其前后必须要有空格，如”width: calc(12%+5em)”这种没有空格的写法是错误的；<br>表达式中有“</em>”和“/”时，其前后可以没有空格，但建议留有空格。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;  &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;  &lt;style&gt;   .box{    width: 100%;    height: 500px;    background-color:red;    border:1px solid blue;  }  .box-child{    width: calc(100% - 100px);    height: calc(100% - 200px);    background-color:yellow;    border:1px solid #eee;  }  &lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;    box    &lt;div class=&quot;box-child&quot;&gt;box-child&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.imgur.com/tgYs6C4.png" alt></p><p>从效果我们可以看出,calc()可以动态计算我们的宽度,而且运算的时候數值”不需要”相同單位.</p><p>此外我们的居中方式也多了一种,通过calc()的话:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;  &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;  &lt;style&gt;    #box{      width: 200px;      height: 200px;      background-color:#eee;      position:absolute;      top:calc(50% - 100px);      left: calc(50% - 100px);    }  &lt;/style&gt;&lt;body&gt;  &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><p><code>attr()</code> 函数返回选择元素的属性值。<br><code>content</code>属性和<code>attr</code>函数,在我们实际开发过程还是十分有用的,就是用来动态生成文本内容并展示在页面上,制作纯<code>CSS</code>的<code>Tooltip</code>;</p><h3 id="attr-的日常使用"><a href="#attr-的日常使用" class="headerlink" title="attr()的日常使用"></a>attr()的日常使用</h3><p>下面让我们看看 attr 和 content 如何相互配合产生神奇效果的<br>    <div class="title" data-title="attr"></div></p><pre><code>div[data-line]:after {     content:attr(data-title);    display:block;    font-size:12px;    margin-top: 10px;}</code></pre><p>在页面就会直接展示attr这段文字了,然后我们通过<code>JavaScript</code>改变<code>data-title</code>的值,就能够动态改变文字的显示了。十分简单.<br>不需要用<code>JavaScript</code>里拼装字符串,CSS3里就能完成这些，是不是感觉CSS3可以部分的替代Javascript了！<br>attr的动态生成页面内容的能力着实是一件让人兴奋的事情。你实际上可以用它配合content对页面的很多其他元素和属性进行操作。</p><h2 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient()"></a>linear-gradient()</h2><p>linear-gradient() 函数用于创建一个线性渐变的 “图像”。<br>以往我们做渐变效果,只能通过图片来实现,但现在有了<code>linear-gradient()</code>,我们就能通过它来制作想要的渐变背景了。<br>为了创建一个线性渐变，你需要设置一个起始点和一个方向（指定为一个角度）的渐变效果。你还要定义终止色。终止色就是你想让Gecko去平滑的过渡，并且你必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。</p><h3 id="linear-gradient-语法"><a href="#linear-gradient-语法" class="headerlink" title="linear-gradient()语法"></a>linear-gradient()语法</h3><pre><code>background: linear-gradient(direction, color-stop1, color-stop2, ...);</code></pre><p><code>direction</code>是指用角度值指定渐变的方向（或角度）。<br> to left：设置渐变为从右到左。相当于: 270deg<br> to right：设置渐变从左到右。相当于: 90deg<br> to top：设置渐变从下到上。相当于: 0deg<br> to bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。<br> xxxdeg:设置渐变角度。<br><code>color-stop1、color-stop2....</code>用于指定渐变的起止颜色,颜色数量不限制,即可以制作大于两种颜色以上的渐变背景。</p><p>因为很简单,所以就不多介绍了,<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient" target="_blank" rel="noopener">详细可看MDN</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型详解</title>
      <link href="/2017/11/05/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/11/05/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在整理收集前端面试题的时候,经常有关于CSS盒模型的问题,属于经典问题了。很多博客里讲得也很模糊不清，于是，我在这里重新整理一下。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。<br>其实就是我们平常F12检查元素的时候页面表示出来的这个图片。</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/25/9cb491d4bd5d326aeb16632280411283?imageView2/0/w/1280/h/960/ignore-error/1" alt></p><p>从上图即可知,正常的一个盒子的内容包括:</p><ol><li>margin</li><li>border</li><li>padding</li><li>content<br>四部分组成。</li></ol><h2 id="分类和区别"><a href="#分类和区别" class="headerlink" title="分类和区别"></a>分类和区别</h2><p>那盒模型是分为 <strong>IE盒模型</strong> 和 <strong>W3C标准盒模型</strong>。</p><h3 id="区别是"><a href="#区别是" class="headerlink" title="区别是?"></a>区别是?</h3><ol><li>W3C 标准盒模型：</li></ol><p>属性<code>width</code>,<code>height</code>只包含内容<code>content</code>，不包含<code>border</code>和<code>padding</code>。</p><ol start="2"><li>IE 盒模型：</li></ol><p>属性<code>width</code>,<code>height</code>包含<code>border</code>和<code>padding</code>，指的是<code>content</code>+<code>padding</code>+<code>border</code>。</p><p>意思是什么呢?<br>就是如果是W3C 标准盒模型,那么我们的宽度和高度就不包括边框和内边距了,即这种模型下,我们如果已经设置了宽高度,那么即便改变了<code>border</code>和<code>padding</code>的大小,也不会改变整个元素的宽高。</p><h2 id="日常开发注意事项"><a href="#日常开发注意事项" class="headerlink" title="日常开发注意事项"></a>日常开发注意事项</h2><p>在我们日常的CSS开发中,默认浏览器渲染的时候都是 W3C 标准盒模型.<br>在这种盒模型下,我们的日常开发会遇到什么问题呢？<br>假设我们设定了一个div元素</p><pre><code>.box{    width:200px;    height:200px;    background-color:pink;}</code></pre><p>这个时候我们检查<code>.box</code>元素,没有意外,高宽都是200px.<br>那接着我们继续添加CSS元素,</p><pre><code>.box{    width:200px;    height:200px;    background-color:pink;    padding:20px;    border:10px solid black;}    </code></pre><p>这个时候我们再检查元素,高宽就变成了 200+20+20+10+10=260 了。<br>说明<code>padding</code>和<code>border</code>会把整个盒子<strong>撑高撑大</strong>。<br>那这种情况给我们的开发者就造成一种困扰,我已经设置高宽是200px的情况下,就是不想要有其他属性再去影响它了.<br>而且如果我们是一行多个元素百分比布局的情况下,一旦给单个元素添加了<code>padding</code>或<code>border</code>元素的话,就会影响单个元素宽度,”一行”变成”两行”,极不美观.</p><p>于是,我们<code>CSS3</code>添加了一个属性:<code>box-sizing</code>,他的默认属性值就是<code>content-box</code>(即 W3C 标准盒模型),那么当我们的把属性值设置为<code>border-box</code>(IE盒模型)之后,以上出现的问题就迎刃而解了。</p><p>因为在这种模型下,我们盒子的宽高度是包括<code>padding</code>和<code>border</code>的,即便我们给某个元素设置了padding或border值,也不会变动元素的宽高度,也不会撑大撑高元素。</p><p>所以在日常CSS开发过程中,在设置全局css中(如bootstrap),我们都会给所有元素添加一个属性就是:</p><pre><code>box-sizing:border-box;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化之图片</title>
      <link href="/2017/10/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87/"/>
      <url>/2017/10/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前端优化中图片优化必要性"><a href="#前端优化中图片优化必要性" class="headerlink" title="前端优化中图片优化必要性"></a>前端优化中图片优化必要性</h2><p>在我们前端优化的种种方案中,包括js、html、css文件的打包压缩合并到极致,我们节省的空间至多也就是几十K的大小,但是在图片领域能够优化的空间,往往能够达到几百k到几M的范畴,这对于一个页面而言,优化力度可是极大的.所以在前端优化中,图片的优化是至关重要的.</p><h2 id="图片格式认知"><a href="#图片格式认知" class="headerlink" title="图片格式认知"></a>图片格式认知</h2><p>目前在项目开发中常见的图片格式,包括有:</p><ul><li>jpg</li><li>png</li><li>gif</li><li>svg</li><li>WebP</li></ul><h3 id="jpg格式"><a href="#jpg格式" class="headerlink" title="jpg格式"></a>jpg格式</h3><p> <code>jpg</code> 全称叫做<code>jpeg</code>,<code>.jpg</code>和<code>.jpeg</code>这两种扩展名的实质是相同的，但因为DOS时代的8.3文件名命名原则是:拓展名不能超过三位,所以直接用作<code>.jpg</code>,虽然现在windows也可以支持任意长度的扩展名了，但大家已经习惯了.jpg的叫法，因此也就没有强制修正.</p><h4 id="baseline-jpeg"><a href="#baseline-jpeg" class="headerlink" title="baseline-jpeg"></a>baseline-jpeg</h4><h4 id="progressive-jpeg"><a href="#progressive-jpeg" class="headerlink" title="progressive-jpeg"></a>progressive-jpeg</h4><p> <img src="http://7tszky.com1.z0.glb.clouddn.com/Fo8q3huYFyQma_rsSvo28dUyd7mN" alt><br> jpeg优势： 非常通用，图片更小<br> jpeg劣势： 图片色彩不够丰富,且不支持透明.</p><h3 id="PNG格式"><a href="#PNG格式" class="headerlink" title="PNG格式"></a>PNG格式</h3><p> <code>PNG</code>,可移植网络图形格式,这种类型的图片可以展示 256 种颜色，而且每一种颜色都可以做成透明,所以这类图片我们常用来做透明和半透明的素材,缺点则是体积较大.</p><h3 id="GIF格式"><a href="#GIF格式" class="headerlink" title="GIF格式"></a>GIF格式</h3><p> <code>GIF</code>,一般都理解为gif动画,其实<code>GIF</code>也可以存储图片,同时也支持透明,但作为图片,<code>GIF</code>只支持透明和不透明,不支持半透明,而且相对于<code>png</code>的图片,<code>GIF</code>的占用空间更大,它的唯一优势在于它是支持动画,而其他格式都不支持,所以一般我们图片是不使用<code>GIF</code>格式,只有在用动画的情况才使用。</p><h3 id="svg格式"><a href="#svg格式" class="headerlink" title="svg格式"></a>svg格式</h3><p> 可缩放矢量图形，属于 XML 格式，百度地图就是使用 svg 绘制的，位图当你放大时单位面积内可视的像素点会变少，所以会失真，也就是我们常说的图片模糊，首先 svg 它是一个可以进行计算矢量图，放大和缩小的时每一个像素会根据向量重新计算，不会失真，并且 svg 的体积很小。</p><h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h3><p> 是 Google 于2010年提出了一种新的图片压缩格式，<code>WebP</code> 为网络图片提供了无损和有损压缩能力，同时在有损条件下支持透明通道；无损 <code>WebP</code> 相比 <code>PNG</code> 减少26%大小，有损 <code>WebP</code> 在相同的结构相似性下相比 <code>JPEG</code> 减少 25%~34% 的大小，所以它也同时具备 <code>jpg</code> 和 <code>png</code> 的优点。<br> 简单来说就是,体积比<code>jpeg</code>更小,而且还支持透明和半透明,渲染速度更快。<br> 但在兼容性上只支持Chrome(29+)、Opera、和Android Brower,firefox和safari都不支持.<br> <img src="http://static.zybuluo.com/jasminecjc/z1ik03y2es81x990qq35hutz/1.png" alt></p><h3 id="图片使用"><a href="#图片使用" class="headerlink" title="图片使用"></a>图片使用</h3><p> 说着这么多的图片类型，我们在项目开发中，如何基于性能和用户体验的权衡来选择合适的图片类型呢？</p><p> 如果是颜色丰富的图片，jpg 是通用的选择。<br> 如果是较通用的动画，gif 是唯一可用的选择。<br> 如果需要清晰的显示颜色丰富和透明的图片，png 是比较好的选择。<br> 如果是企业级应用（不考虑兼容性），可以选择 WebP。</p><h2 id="目前比较流行的做法"><a href="#目前比较流行的做法" class="headerlink" title="目前比较流行的做法"></a>目前比较流行的做法</h2><h4 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h4><p> 智图: <a href="http://zhitu.isux.us/" title="智图" target="_blank" rel="noopener">http://zhitu.isux.us/ </a><br> Kraken: <a href="https://kraken.io/" title="Kraken " target="_blank" rel="noopener">https://kraken.io/</a></p><h4 id="CSS-Sprites-雪碧图"><a href="#CSS-Sprites-雪碧图" class="headerlink" title="CSS Sprites(雪碧图)"></a>CSS Sprites(雪碧图)</h4><p> <strong>场景</strong>：任何用到页面图片的场景<br> <strong>原理</strong>：将多个页面上用到的背景图片合并成一个大的图片在页面中引用<br> <strong>优势</strong>：可以有效的较少请求个数，而且，而不影响开发体验，使用构建插件可以做到对开发者透明。适用于页面图片多且丰富的场景。<br> <strong>劣势</strong>：生成的图片体积较大，减少请求个数同时也增加了图片大小，不合理拆分将不利于并行加载。</p><h4 id="使用base64编码代替图片"><a href="#使用base64编码代替图片" class="headerlink" title="使用base64编码代替图片"></a>使用base64编码代替图片</h4><p> 适用于图片大小小于2KB，页面上引用图片总数不多的情况,可以减少http请求。</p><h4 id="iconfont、CSS3代替图片"><a href="#iconfont、CSS3代替图片" class="headerlink" title="iconfont、CSS3代替图片"></a>iconfont、CSS3代替图片</h4><p> css方式可以用来绘制相对简单的图来代替图片，一般使用before或者after伪元素来丰富图案的复杂度。<br> iconfont可以代替传统图片的icon.<br> 这两种方式都是为了减少网页中图片的使用。</p><h4 id="响应式动态图片加载"><a href="#响应式动态图片加载" class="headerlink" title="响应式动态图片加载"></a>响应式动态图片加载</h4><p> <strong>场景</strong>：不同终端对同一个图片需求不一样，可以根据终端加载不同的图片来节省没必要的流量<br> <strong>原理</strong>：通过picture元素，picturefill或平台判断来为不同终端平台输出不同的图片<br> <strong>优势</strong>：减少没必要的图片加载，灵活控制，慢速用户加载小图片不至于加载失败，移动端没必要加载大尺寸图片等，可以通过不同方式兼容所有浏览器<br> <strong>劣势</strong>：无法避免图片的加载过程，图片本身没优化</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Virtual DOM原理概述</title>
      <link href="/2017/10/24/VirtualDOM%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2017/10/24/VirtualDOM%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="http://it.dyg.cn/wp-content/uploads/2017/10/timg-2.jpg" alt="Virtual DOM"></p><h2 id="Virtual-DOM概念的诞生"><a href="#Virtual-DOM概念的诞生" class="headerlink" title="Virtual DOM概念的诞生"></a>Virtual DOM概念的诞生</h2><p>先来说说<code>Virtual DOM</code>的起源,<code>Virtual DOM</code>的概念最早是在<code>React中</code>被提出来的,<a href="http://www.xposean.xin/2017/10/24/%E5%BD%B1%E5%93%8D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%83%E5%87%B6-DOM%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener">上一节</a>我们也说了,<code>DOM</code>操作是十分耗费性能,因为动不动操作就会引发回流，即渲染整个DOM树,对于移动端浏览器或者是复杂的页面来讲,这简直就是噩梦。</p><p>于是,聪明的工程师们就发明了一种<code>MVVM</code>模式,即视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。只要在模版中声明视图组件是和什么状态进行绑定的，通过改变状态，双向绑定引擎就会在状态更新的时候自动更新视图。</p><p>MVVM模式让我们大大减少代码中的DOM操作次数，其次可以提高<code>DOM</code>的渲染性能,因为他是通过模板引擎和JS构建修改DOM的,很大程度的减少了回流产生的次数。<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171022220758.png" alt></p><p>相对于 <code>DOM</code> 对象，原生的 <code>JavaScript</code> 对象处理起来更快，而且更简单。<code>DOM</code> 树上的结构、属性信息我们都可以很容易地用 <code>JavaScript</code> 对象表示出来。</p><p>但是它同时也存在什么问题呢?</p><p>那就是一旦我们所绑定的某一个状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧  的视图。</p><p>这样的做法会导致很多的问题。最大的问题就是这样做还是会很慢，因为即使一个小小的状态变更都要重新构造整棵 <code>DOM</code>，性价比太低；最后的结论会是：对于局部的小视图的更新，没有问题；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。</p><p><code>AngularJS</code>就是使用这个方式。</p><p>那么工程师经过改进呢,就发明了<code>Virtual DOM</code>啦!</p><h2 id="Virtual-DOM凭什么更加优秀"><a href="#Virtual-DOM凭什么更加优秀" class="headerlink" title="Virtual DOM凭什么更加优秀?"></a>Virtual DOM凭什么更加优秀?</h2><p>其实 <code>Virtual DOM</code> 跟MVVM模式是基本类似的，只是加了一些特别的步骤(diff)来避免了整棵 <code>DOM</code> 树变更。<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171022220758-1.png" alt></p><p><img src="https://camo.githubusercontent.com/a32766a14f6b7fbe631475ed1a186fbd9de7f2c3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f636f6d706172652d696e2d6c6576656c2e706e67" alt></p><h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面:"></a>性能方面:</h3><ol><li><p>用JS构建虚拟DOM树,再通过虚拟DOM构建真正的DOM,这种方式性能快的多。</p></li><li><p>如果我们直接调用像.getElementById的方法,在复杂DOM的页面上,是十分耗费性能的,而在这只需要操作对应的JS对象即可。</p></li><li>比较两棵虚拟DOM树的不同,在真正的DOM元素上进行最小化修改(模板引擎).</li></ol><h3 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面:"></a>代码方面:</h3><ol><li>MVVM模式下,也使我们无需关注DOM元素,直接操作DOM元素对应的状态就行,对于代码编辑更好。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>影响前端性能的元凶:DOM操作</title>
      <link href="/2017/10/24/%E5%BD%B1%E5%93%8D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%83%E5%87%B6-DOM%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/10/24/%E5%BD%B1%E5%93%8D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%83%E5%87%B6-DOM%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>今天我们来谈谈影响前端性能的主要元凶:<strong>DOM操作.</strong></p><h2 id="重视DOM操作的原因"><a href="#重视DOM操作的原因" class="headerlink" title="重视DOM操作的原因?"></a>重视DOM操作的原因?</h2><p>在<strong>PC浏览器</strong>的时代,一般的小批量重绘或回流是感觉不出浏览器卡顿的,这主要是因为PC端的浏览器性能强而且网速够快,但到了如今我们的<strong>移动浏览器</strong>时代,轻微的DOM操作,在我们性能稍弱,网速不够快的移动浏览器上,影响性能的表现就会很明显了。</p><h2 id="DOM操作为什么会影响性能"><a href="#DOM操作为什么会影响性能" class="headerlink" title="DOM操作为什么会影响性能"></a>DOM操作为什么会影响性能</h2><p>在浏览器中，<code>DOM</code>的实现和<code>ECMAScript</code>的实现是分离的。所以通过<code>JavaScript</code>代码调用DOM接 口，相当于两个独立模块的交互。相比较在同一模块中的调用，这种跨模块的调用其性能损耗是很高的。但<code>DOM</code>操作对性能影响最大其实还是因为它导致了浏览器 的<strong>重绘</strong>和<strong>回流</strong>。</p><p><strong>重绘</strong>（repaint）:当前元素的颜色样式(背景颜色、字体颜色等)发生改变的时候，我们只需要把改变的元素重新的渲染一下即可，重绘主要改变外观风格（改个颜色，换个皮肤），不改变布局，不影响其他的dom。</p><p><strong>回流</strong>（reflow）:指浏览器为了重新渲染部分或者全部的文档而重新计算文档中元素的位置和几何构造的过程。如<code>DOM</code>元素的增删、位置移动、尺寸大小的改变以及浏览器窗口尺寸改变。每个页面至少会有一次回流,就是在页面初次渲染的时候。</p><p>这其中,重绘对浏览器的性能影响较小,一般不做优化，但是能避免最好.主要是回流需要尽可能避免和优化。</p><h2 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h2><p>在渲染页面的过程中，浏览器会通过解析HTML文档来构建DOM树，解析<code>CSS</code>产生<code>CSS</code>规则树。<code>JavaScript</code>代码在解析过程中， 可能会修改生成的<code>DOM树</code>和<code>CSS</code>规则树。之后根据<code>DOM</code>树和<code>CSS</code>规则树构建渲染树，在这个过程中<code>CSS</code>会根据选择器匹配HTML元素。渲染树包括了每 个元素的大小、边距等样式属性，渲染树中不包含隐藏元素及<code>head</code>元素等不可见元素。最后浏览器根据元素的坐标和大小来计算每个元素的位置，并绘制这些元 素到页面上。重绘指的是页面的某些部分要重新绘制，比如颜色或背景色的修改，元素的位置和尺寸并没用改变；回流则是元素的位置或尺寸发生了改变，浏览器需 要重新计算渲染树，导致渲染树的一部分或全部发生变化。渲染树重新建立后，浏览器会重新绘制页面上受影响的元素。<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/snipaste_20171013_112243.png" alt></p><p>这就是DOM树<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/w_800-750x334.png" alt="DOM树"></p><p><strong>回流</strong>的代价比<strong>重绘</strong>的代价高很多，重绘会影响部分的元素，而回流则有可能影响全部的元素。</p><blockquote><p>注意：回流必将引起重绘，而重绘不一定会引起回流。</p></blockquote><h2 id="那我们怎样优化和避免重绘和回流"><a href="#那我们怎样优化和避免重绘和回流" class="headerlink" title="那我们怎样优化和避免重绘和回流?"></a>那我们怎样优化和避免重绘和回流?</h2><h3 id="1-合并多次的DOM操作为单次的DOM操作"><a href="#1-合并多次的DOM操作为单次的DOM操作" class="headerlink" title="1. 合并多次的DOM操作为单次的DOM操作"></a>1. 合并多次的DOM操作为单次的DOM操作</h3><pre><code>var element = document.getElementById(&apos;content&apos;);//多次的DOM操作element.style.borderColor = &apos;white&apos;;element.style.borderStyle = &apos;solid&apos;;element.style.borderWidth = &apos;1px&apos;;//优化方案:1.可合并为一次element.style.cssText += &apos;border: 1px solid white;background-color:green;&apos;;//2.添加classNameelement.className += &apos;empty&apos;;</code></pre><h3 id="2-把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上"><a href="#2-把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上" class="headerlink" title="2.把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上"></a>2.把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上</h3><p>把DOM元素从页面流中脱离或隐藏，这样处理后，只会在DOM元素脱离和添加时，或者是隐藏和显示时才会造成页面的重绘或回流，对脱离了页面布局流的DOM元素操作就不会导致页面的性能问题。这种方式适合那些需要大批量修改DOM元素的情况。</p><pre><code>var myElement = document.getElementById(&apos;content&apos;);myElement.style.display = &apos;none&apos;;// 一些基于myElement的大量DOM操作...myElement.style.display = &apos;block&apos;;</code></pre><h3 id="3-克隆DOM元素到内存中"><a href="#3-克隆DOM元素到内存中" class="headerlink" title="3.克隆DOM元素到内存中"></a>3.克隆DOM元素到内存中</h3><p>这种方式是把页面上的DOM元素克隆一份到内存中，然后再在内存中操作克隆的元素，操作完成后使用此克隆元素替换页面中原来的DOM元素。这样一来，<strong>影响性能的操作就只是最后替换元素的这一步操作了，在内存中操作克隆元素不会引起页面上的性能损耗</strong>。</p><pre><code>var old = document.getElementById(&apos;content&apos;);var newElement= old.cloneNode(true); //复制DOM元素到内存中// 一些基于clone的大量DOM 操作...//替换原来DOM元素old.parentNode.replaceChild(newElement, old);</code></pre><h3 id="4-使用JS模板引擎"><a href="#4-使用JS模板引擎" class="headerlink" title="4.使用JS模板引擎"></a>4.使用JS模板引擎</h3><p>在大批量的<code>DOM</code>元素操作,其实最方便或最有效的操作,应该是使用JS模板引擎,例如有<code>artTemplate</code>、<code>Mustache</code>等</p><h3 id="5-使用Virtual-DOM"><a href="#5-使用Virtual-DOM" class="headerlink" title="5.使用Virtual DOM."></a>5.使用Virtual DOM.</h3><p>这也是目前主流的前端框架(<code>Reac</code>t、<code>Vue</code>、<code>Angular</code>)所使用的方式,将会在<a href="http://www.xposean.xin/2017/10/24/VirtualDOM%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener">下一节</a>详细讲述。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery的插件机制</title>
      <link href="/2017/10/24/jQuery%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/10/24/jQuery%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery框架现况分析和概述"><a href="#jQuery框架现况分析和概述" class="headerlink" title="jQuery框架现况分析和概述"></a>jQuery框架现况分析和概述</h2><p><img src="http://it.dyg.cn/wp-content/uploads/2017/09/151009222057-15-1-300x207.png" alt><br>虽然jQuery的市场占有率正逐年下滑,但不可避免的,jQuery仍是目前前端领域里使用率最高的前端框架,仍旧需要深入学习它,利用它更方便的写出优秀的前端代码。</p><p>先来回顾一下,jQuery的优秀之处:</p><ol><li>强大的DOM选择器</li><li>可靠的事件处理器</li><li>完善的Ajax函数</li><li>链式操作</li><li>出色的浏览器兼容性</li><li>强大的插件支持</li></ol><p>而本篇文章主要讲解的就是<code>jQuery</code>框架强大的<strong>插件系统</strong>支持,且听我慢慢道来.</p><h2 id="jQuery的插件系统概述"><a href="#jQuery的插件系统概述" class="headerlink" title="jQuery的插件系统概述"></a>jQuery的插件系统概述</h2><p>首先编写插件的目的很明确,就是为了能够让代码的<strong>复用性更强</strong>,<strong>提高可维护性和开发效率</strong>。</p><p>那首先,<code>jquery</code>的插件主要分为三种类型:</p><h3 id="封装对象方法的插件"><a href="#封装对象方法的插件" class="headerlink" title="封装对象方法的插件"></a>封装对象方法的插件</h3><p>这种是将对象方法封装起来,用于对通过选择器获得JQuery对象进行操作,也是最常用的插件类型。</p><p>简单的举例就是我们在<code>jQuery</code>用的<code>addClass()</code>、<code>parent()</code>此类的方法都是属于这种类型的插件。</p><h3 id="封装全局函数的插件"><a href="#封装全局函数的插件" class="headerlink" title="封装全局函数的插件"></a>封装全局函数的插件</h3><p>可以将独立的函数(方法)加到JQuey命名空间下.例如<code>jQuery</code>中的<code>$.Ajax()</code>和<code>$.trim()</code>这种就属于<code>jquery</code>编写的作为全局函数使用的插件。</p><h3 id="选择器插件"><a href="#选择器插件" class="headerlink" title="选择器插件"></a>选择器插件</h3><p>这个就很好理解了,虽然我们的Jquery的选择器非常的强大且丰富,但仍不是尽善尽美的,仍然有时候需要扩展一些我们自定义的选择器。</p><p><strong>注意事项:</strong><br>为了防止我们内部编写的变量影响到全局空间,我们在编写插件的时候必须通过一段代码来包裹我们的编写的代码体。</p><pre><code>;(function($){    /* 放置我们的插件代码,并且可以通过$来作为JQuery的缩写别名*/})(jQuery);</code></pre><p>这样的话,我们写的插件里的变量不会污染到全局空间,而且我们在代码中还能继续使用过$来作为<code>jQuery</code>的缩写别名.</p><h2 id="JQuery的插件机制"><a href="#JQuery的插件机制" class="headerlink" title="JQuery的插件机制"></a>JQuery的插件机制</h2><p>简单介绍了<code>jQuery</code>插件以及其类型,我们再来讲讲<code>jQuery</code>的插件机制,<code>jQuery</code>是用什么来创建我们的插件的呢？</p><p><code>jQuery</code>提供了两个用于扩展<code>JQuery</code>功能的方法,即<code>jQuery.fn.extend(</code>)和<code>jQuery.extend()</code>方法。</p><p><code>jQuery.fn.extend()</code>用来扩展我们前面提到的第一种类型的插件,</p><p><code>jQuery.extend()</code>用来扩展第二和第三类型的插件。</p><p>这两个方法都接受一个<code>Object</code>类型的参数。</p><h2 id="编写jQuery插件"><a href="#编写jQuery插件" class="headerlink" title="编写jQuery插件"></a>编写jQuery插件</h2><h3 id="封装JQuery对象方法的插件"><a href="#封装JQuery对象方法的插件" class="headerlink" title="封装JQuery对象方法的插件"></a>封装JQuery对象方法的插件</h3><p>在这里我们要编写一个能够设置对象颜色的插件。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;script class=&quot;jquer&quot; src=&quot;/js/sandbox/jquery/jquery-1.8.2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;    &lt;title&gt;演示代码&lt;/title&gt;  &lt;/head&gt;&lt;body&gt;    &lt;div class=&apos;content&apos;&gt;hello&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;&lt;script&gt;;(function($){  jQuery.fn.extend({    &quot;color&quot;:function(value){      return this.css(&apos;color&apos;,value);    }  })})(jQuery);$(function(){  $(&apos;.content&apos;).color(&apos;red&apos;);});&lt;/script&gt;</code></pre><p>在这段代码中,我们通过<code>$.fn.extend()</code>就能够封装一个JQ对象的插件函数了。</p><p>通过<code>$(&#39;xxx&#39;).color(&#39;color&#39;)</code>,我们就能直接给DOM元素设置颜色了,极其方便好用。</p><h3 id="封装全局函数的插件-1"><a href="#封装全局函数的插件-1" class="headerlink" title="封装全局函数的插件"></a>封装全局函数的插件</h3><p>同样的我们可以编写一个能够清除去除左侧空格的插件函数。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;  &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.js&quot;&gt;&lt;/script&gt;  &lt;div class=&quot;content1&quot;&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;;(function($){    $.extend({        ltrim:function(text){            return (text||&quot;&quot;).replace(/^\s+/g,&quot;&quot;);        }    });})(jQuery);$(function(){    var str = &quot;           2222&quot;;    alert($.ltrim(str));});&lt;/script&gt;</code></pre><p>在这段代码里,我们定义了一个全局函数的插件,来实现去除字符串左侧空格的功能,通过<code>$.extend()</code>设置后,我们就可以直接通过<code>$.ltrim(xxx)</code>来设置了。</p><h3 id="封装自定义选择器"><a href="#封装自定义选择器" class="headerlink" title="封装自定义选择器"></a>封装自定义选择器</h3><p>首先,我们以自带的选择器例子来做介绍:</p><pre><code>$(&quot;div:gt(1)&quot;)</code></pre><p>这个例子中,选择器会首先找到所有div的元素,再遍历这些元素,然后将这些元素和”1″和下标一起传入gt选择器对应的选择器函数中。根据函数里编写的代码,如若返回true,则该元素会保留,反之,该元素就会被忽略。</p><p>而例子中的gt选择器函数转化成自定义的<strong>选择器函数</strong>是这样的:</p><pre><code>function(a,i,m){  return i&gt;m[3]-0;}</code></pre><p>第一个参数a:指的是当前遍历的DOM元素;</p><p>第二个参数i:指的是当前遍历的DOM元素的索引值,从0开始;</p><p>第三个参数m:他是由JQuery解析出来的一个数组.<br><img src="http://it.dyg.cn/wp-content/uploads/2017/09/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170910170144.png" alt></p><p>介绍完这些,接下来我们来自己编写一个自定义的选择器:</p><p>创建一个根据你传入的字符串等于DOM元素文本内容的选择器:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;  &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.js&quot;&gt;&lt;/script&gt;  &lt;p&gt;111&lt;/p&gt;  &lt;p&gt;222&lt;/p&gt;  &lt;p&gt;333&lt;/p&gt;  &lt;p&gt;444&lt;/p&gt;  &lt;p&gt;555&lt;/p&gt;  &lt;p&gt;666&lt;/p&gt;  &lt;p&gt;777&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;;(function($){  $.extend($.expr[&quot;:&quot;],{    &quot;equal&quot;: function(a,i,m){      return $(a).text()==m[3];    }  });})(jQuery);$(function(){  $(&apos;p:equal(111)&apos;).css(&apos;color&apos;,&quot;red&quot;);});&lt;/script&gt;</code></pre><p>该选择器会根据传入的字符找到字符相等的元素。</p><p>因为选择器函数是属于调用<strong>十分频繁</strong>的函数,所以在编写的时候,一定要秉承优化再优化的原则,不能草草了事。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是jQuery的插件系统,利用好插件,可以给我们的开发工作带来十分大的效率提升。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动web适配方案简述</title>
      <link href="/2017/10/24/%E7%A7%BB%E5%8A%A8web%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/"/>
      <url>/2017/10/24/%E7%A7%BB%E5%8A%A8web%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>众所周知,目前移动设备的访问量早已超越PC端设备,这就意味着用户使用移动设备访问页面的行为越发频繁,这就给web前端开发人员带来了一系列的苦恼,如何才能在不同大小的设备上呈现同样的网页？这是每一个移动web开发者的都会发出的疑问.接下来,本文将讲述自适应网页设计的概念和方法，使网页开发人员维护同一个网页代码，即可使网站在多种设备上具有更好的阅读体验。</p><blockquote><p>本文详细介绍了网页全适配的实现方法，希望能给迷惑的你带来帮助。</p></blockquote><h2 id="先说说方案"><a href="#先说说方案" class="headerlink" title="先说说方案"></a>先说说方案</h2><p>目前主流的方案有两个,<strong>响应式</strong>以及<strong>自适应</strong>的解决方案,除此之外也有其他的方案,但在这主要只讲这两者.<br><img src="http://it.dyg.cn/wp-content/uploads/2017/08/eb206edc273b0ac47a7da1f157010bad_r.png" alt><br><strong>自适应</strong>:在移动端设备上浏览，网页与PC端无大的差别，原网页的布局在任何设备上都可以保持一致，不会因为屏幕窄宽大小而会影响视觉效果（不会被遮挡）和响应效果。<br><strong>响应式</strong>:在手机等设备上浏览，网页与PC端内容相似，但布局是自动改变为专为手机等其他设备所准备的。</p><h3 id="自适应方案"><a href="#自适应方案" class="headerlink" title="自适应方案"></a>自适应方案</h3><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/459873-20151014135809710-1472399325.png" alt></p><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/459873-20151014135813913-563846656.png" alt></p><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/459873-20151014135815319-1600880598.png" alt></p><p>拉勾网和简书网的页面就属于是自适应方案,这种页面有以下特别:</p><p>1.文字流式;</p><p>2.控件弹性</p><p>3.图片等比缩放</p><p>4.顶部或底部的的bar无论宽度怎么变,高度和位置不变.</p><p>但自适应布局更多用在页面元素相对没那么复杂的网站,如果是比较复杂的网站,并不推荐使用这个布局,简单的说，图片为主内容的可以用自适应布局,例如花瓣网这种.</p><hr><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>目前一般常见的实现响应式有两种方法，一种是利用<strong>媒体查询</strong>，另外一种利用<strong>JS计算屏幕宽度做出响应</strong>.</p><p>但从性能和易用程度上,推荐使用媒体查询,媒体查询可以针对不同的屏幕尺寸设置不同的样式,对于响应式布局的页面,非常有用.</p><p>bootstrap的 <strong>栅格布局</strong> 就是根据这种原理实现的。</p><h4 id="当页面宽度大于1200px"><a href="#当页面宽度大于1200px" class="headerlink" title="当页面宽度大于1200px:"></a>当页面宽度大于1200px:</h4><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/snipaste_20170814_210916-750x425.png" alt></p><hr><h4 id="当页面宽度大于900px并且小于1200px"><a href="#当页面宽度大于900px并且小于1200px" class="headerlink" title="当页面宽度大于900px并且小于1200px:"></a>当页面宽度大于900px并且小于1200px:</h4><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/snipaste_20170814_210928-300x226.png" alt></p><hr><h4 id="当页面宽度小于900px"><a href="#当页面宽度小于900px" class="headerlink" title="当页面宽度小于900px:"></a>当页面宽度小于900px:</h4><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/snipaste_20170814_210940-182x300.png" alt></p><hr><p>但这种布局,会存在一个问题,那就是元素字体、间距、宽高等属性的属性值不会随着屏幕的宽度进行放大或缩小,这个时候,就得动态改变我们的css单位了.</p><h4 id="em相对单位"><a href="#em相对单位" class="headerlink" title="em相对单位"></a>em相对单位</h4><p>em的特点 : 1. em的值并不是固定的; 2.em始终会继承父级元素的字体大小。</p><p>但因为em在易用性上不强,且父级元素继承关系容易紊乱,所以又推出了rem单位.</p><h4 id="rem相对单位"><a href="#rem相对单位" class="headerlink" title="rem相对单位"></a>rem相对单位</h4><p>rem也是相对单位,但它是基于根元素(也就是html标签)做相对大小,这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应.</p><h4 id="Js动态设置rem来实现移动端字体的自适应"><a href="#Js动态设置rem来实现移动端字体的自适应" class="headerlink" title="Js动态设置rem来实现移动端字体的自适应"></a>Js动态设置rem来实现移动端字体的自适应</h4><p>原理就是:利用Js获取设备屏幕的宽度，并根据屏幕的宽度动态改变根元素html的font-size属性的作用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果在不考虑人力成本和时间成本的话,只考虑页面效果,首推PC端和移动端各自两套页面布局,这样方案是最合适;甚至可以移动端自适应布局,pc端响应式布局.</p><p>例如我们<a href="http://www.dyg.cn" target="_blank" rel="noopener">东阳光商城</a>,就是两套布局方案.</p><p>以及百度、淘宝、知乎,这些大型的网站都是这样,主要还是因为考虑到业务等各方面的原因.</p><p>因为虽然响应式和自适应能够达到我们的效果,但在细节之处总是不够尽如人意,同时在页面布局上是固定几个模板的,不能更加的别出心栽和创意.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>来聊聊localStorage、sessionStorage和cookie</title>
      <link href="/2017/10/24/%E6%9D%A5%E8%81%8A%E8%81%8AlocalStorage%E3%80%81sessionStorage%E5%92%8Ccookie/"/>
      <url>/2017/10/24/%E6%9D%A5%E8%81%8A%E8%81%8AlocalStorage%E3%80%81sessionStorage%E5%92%8Ccookie/</url>
      
        <content type="html"><![CDATA[<p>首先当然还得是来介绍一下基本概念.</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>对于<code>Cookie</code>,不用介绍的太多,想必大家也都很熟悉了.<code>Cookie</code>实际上是一小段的文本信息,每个Cookie的大小限制为4KB.</p><p>它的主要用途有保存登录信息，比如你登录某个网站市场可以看到浏览器提醒你需要“记住密码”，这通常就是通过在 <code>Cookie</code> 中存入一段辨别用户身份的数据来实现的。</p><h3 id="web-Storage"><a href="#web-Storage" class="headerlink" title="web Storage"></a>web Storage</h3><p><code>sessionStorage</code> 和 <code>localStorage</code> 是<strong>HTML5 Web Storage API</strong> 提供的，可以方便的在<code>web</code>请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</p><p>在这之前,客户端存储数据都是使用cookie,但是大家都知道,每一次HTTP请求,都会带着cookie给后端,即使是不需要传输的情况下,这在无形之中就增加带宽的浪费,而<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p><h3 id="三者的异同"><a href="#三者的异同" class="headerlink" title="三者的异同"></a>三者的异同</h3><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/Snipaste_2017-08-05_21-13-28.png" alt></p><p><strong>通过上图的表,大概总结一下webstorage API的好处:</strong><br>1.<strong> 减少网络流量</strong>：一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。</p><ol start="2"><li><strong>快速显示数据</strong>：性能好，从本地读数据比通过网络从服务器获得数据快得多，本地数据可以即时获得。再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。<br>3.<strong> 临时存储</strong>：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用<code>sessionStorage</code>非常方便。</li><li><strong>更多丰富易用的接口</strong>：<code>Web Storage</code>提供了一套更为丰富的接口，使得数据操作更为简便。</li></ol><h2 id="Webstorage-API的简单使用"><a href="#Webstorage-API的简单使用" class="headerlink" title="Webstorage API的简单使用"></a>Webstorage API的简单使用</h2><pre><code>//创建localStorage对象var localstroage = window.localStorage;  //存储值localstroage.setItem(&apos;name&apos;,&apos;Jack&apos;);  localstroage.setItem(&apos;uid&apos;,&apos;10001&apos;);  //获取值var openid = localstroage.getItem(&apos;openid&apos;);  console.log(openid);//删除值localstroage.removeItem(&apos;openid&apos;);  //清空值localstroage.clear(); </code></pre><p>而<code>sessionStorage</code>的使用则与<code>localStorage</code>完全一致.</p><p>此外,HTML5在提供了<code>storage</code>事件,当键值改变或者clear的时候，就可以触发<code>storage</code>事件,相当于加了个监听事件,这也是<code>cookie</code>原生没有的.</p><p>##应用场景和总结</p><p>我们的Storage API,可以用在<strong>IM聊天记录</strong>,<strong>购物车</strong>,<strong>HTML5的游戏数据存储</strong>,<strong>内容多的表单</strong>.<br>并非说有了<code>localStorage</code>、<code>sessionStorage</code>,<code>cookie</code>就会被淘汰了,就目前的客户端(浏览器)使用而言,<code>cookie</code>的使用率仍然是非常高的,只是在某种特定的情况下呢,使用我们的webStorageAPI会更加方便好用,更快的解决问题.</p><p>此外,我们的<code>webStorageAPI</code>也仍存在一些局限,一个是兼容性问题,是不支持IE8以下的,还有一个是如果用户使用的是浏览器的隐身模式的话,是无法访问用<code>localStorage</code>存储下来的值的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gulp入门</title>
      <link href="/2017/10/24/Gulp%E5%85%A5%E9%97%A8/"/>
      <url>/2017/10/24/Gulp%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Gulp是啥子东西？"><a href="#Gulp是啥子东西？" class="headerlink" title="Gulp是啥子东西？"></a>Gulp是啥子东西？</h2><p><img src="http://www.d1net.com/uploadfile/2017/0112/20170112092834684.png" alt></p><p>一句话简单的概括,就是一个前端项目自动化的构建工具。不理解没关系,容我慢慢道来。</p><p>首先要说说<code>Gulp</code>诞生的原因.</p><p>随着 <code>Web</code> 前端发展，前端项目变得越来越复杂，随之而来的是各种方便的工具：打包工具、转码工具、 <code>JS</code> 与 <code>CSS</code> 的合并压缩工具等等。这些工具极大的提高了我们前端的代码质量，但问题也随之而来：</p><p>这么多工具到底该怎么使用，难道一个个在各个工具中来回切换复制粘贴？或是在 CLI 里一条条地敲命里吗？敲完代码还要敲一堆的构建命令，说不准顺序搞错了还要功亏一篑重来一遍？</p><p>于是我们的构建工具 <code>Gulp</code> 就应运而生啦。</p><h3 id="Gulp有啥好处？"><a href="#Gulp有啥好处？" class="headerlink" title="Gulp有啥好处？"></a>Gulp有啥好处？</h3><p>首先当然是省心省力啦,<strong>一次配置,自动构建</strong>.我把我需要的功能配置出来后,以后直接用<code>Gulp</code>调用就好了,Gulp会帮我整合好我需要的功能。</p><p>第二个就是重复利用啦,因为配置文件的高度统一，这个配置文件几乎可以多个项目之间随便复制粘贴修修改改就可以重复使用！</p><h2 id="Gulp能做什么"><a href="#Gulp能做什么" class="headerlink" title="Gulp能做什么"></a>Gulp能做什么</h2><p>当你按下 <code>ctrl+s</code> 时,你发现你的电脑自动帮你编译、压缩、打包、自动刷新。你会不会觉得很爽呢？</p><p>下面我来说说Gulp的常用功能。</p><ul><li>静态文件的合并与压缩:JS 、css、html的压缩</li><li>图片(包括PNG、JPEG、GIF和SVG图片)的压缩,在不降低画质的情况下,降低图片的大小。</li><li>页面自动刷新,你的代码有任何变动都会刷新。</li><li>还有一些CSS预编译器(sass、less),ES6语法,都可以自动编译成浏览器能够识别的。</li><li>图片路径转base64<br>等等….<br>而这些功能的实现在配置完后你只需要做什么, <code>ctrl+s</code> !!!</li></ul><h2 id="Gulp的运行和安装"><a href="#Gulp的运行和安装" class="headerlink" title="Gulp的运行和安装"></a>Gulp的运行和安装</h2><p>关于Gulp的环境配置和安装,可以直接点击<a href="http://www.ydcss.com/archives/18" target="_blank" rel="noopener">这里查看教程</a>。</p><p>看完之后,有两个配置文件是我们一定要重视的,一个是<strong>gulpfile.js</strong>,另一个是<strong>package.json</strong>.如果其他人想要复制你的 <code>gulp</code> 功能属性,这两个文件是必须必备的。</p><p><strong>package.json</strong>是基于<code>nodejs</code>项目必不可少的配置文件，它是存放在项目根目录的普通json文件,里面存放是项目的一些基本配置,以及你安装的所有gulp插件.</p><p>当我们已经把所有的配置都安装好了之后，我们需要在gulpfile.js文件里面写我们的任务(task),我们需要在什么时候用什么插件,都要写在这里。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/2017/10/24/Flex%E5%B8%83%E5%B1%80/"/>
      <url>/2017/10/24/Flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>开篇我们先来看看传统的CSS布局格式,布局的传统解决方案：</p><p>基于盒状模型，依赖 <code>display</code> 属性 + <code>position</code>属性 + <code>float</code>属性。它对于那些特殊布局非常不方便，比如，垂直居中和绝对居中就很不容易实现。况且 <code>float</code> 用多了还得清除浮动.</p><h2 id="Flex是什么鬼"><a href="#Flex是什么鬼" class="headerlink" title="Flex是什么鬼?"></a>Flex是什么鬼?</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt></p><p><code>Flex</code> 是 <code>Flexible Box</code> 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 <code>Flex</code> 布局,只要加个 <code>display</code> 属性。<br>在这里先不考虑各浏览器的适配问题.在文末会提供解决方案。</p><p>注意，设为 <code>Flex</code> 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用 <code>Flex</code> 布局的元素，称为 <code>Flex</code> 容器（flex container），简称”<strong>容器</strong>“。它的所有子元素自动成为容器成员，称为 <code>Flex</code> 项目（flex item），简称”<strong>项目</strong>“。</p><p>通俗的说,就是<strong>容器</strong>是父元素,<strong>项目</strong>是子元素。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt></p><p>容器默认存在两根轴：水平的<strong>主轴</strong>（main axis）和垂直的<strong>交叉轴</strong>（cross axis）。其实就是<strong>横轴</strong>和<strong>纵轴</strong>。</p><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul><li><code>flex-direction</code>(属性决定主轴的方向（即项目的排列方向))</li><li><code>flex-wrap</code>(<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。)</li><li><code>flex-flow</code>(<code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式)</li><li><code>justify-content</code>(定义了项目在主轴上的对齐方式)</li><li><code>align-items</code>(定义项目在交叉轴上如何对齐)</li><li><code>align-content</code>(<code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。)</li></ul><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li><code>order</code>(性定义项目的排列顺序。数值越小，排列越靠前，默认为0。)</li><li><code>flex-grow</code>(属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。)</li><li><code>flex-shrink</code>(属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。)</li><li><code>flex-basis</code>(属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。)</li><li><code>flex</code>(是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为0 1 auto)</li><li><code>align-self</code>(属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性)</li></ul><p>关于 Flex 布局的语法基础就讲到这里，相信能看到这里你一定会有收获。</p><p>如果你看完还是一头雾水的话，没关系，可以看<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="兼容性与各浏览器差异性解决方案"><a href="#兼容性与各浏览器差异性解决方案" class="headerlink" title="兼容性与各浏览器差异性解决方案"></a>兼容性与各浏览器差异性解决方案</h2><p>通过<code>PostCSS</code>的<code>autoprefixer</code>插件,即能自动添加浏览器私有前缀,防止出现各大浏览器中展示效果不同的情况。</p><p>访问这篇文章<a href="http://www.xposean.xin/2017/10/24/PostCSS%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">《PostCSS入门》</a>。</p><p>如果不想麻烦使用<code>PostCSS</code>,也可以通过<code>gulp</code>安装<a href="http://www.ydcss.com/archives/94" target="_blank" rel="noopener">gulp-autoprefixer</a>插件,一样可以达到效果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PostCSS入门</title>
      <link href="/2017/10/24/PostCSS%E5%85%A5%E9%97%A8/"/>
      <url>/2017/10/24/PostCSS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我想你应该已经听说过<a href="http://postcss.com/" target="_blank" rel="noopener">PostCSS</a>,它比<a href="https://github.com/postcss/benchmark#preprocessors" target="_blank" rel="noopener">libsass</a>快了几乎两倍(并且比Ruby Sass快了28倍)； 或者听说过它支持<a href="http://cssnext.io/" target="_blank" rel="noopener">cssnext</a>和自动添加私有前缀而且可扩展功能,难道你一点都不好奇吗？</p><p>PostCSS最强大之处在于它是模块化并且基于插件的架构，不过这也是个缺点。如果你之前在项目中使用Sass(比如大多数的设计师和前端开发者)，你从不需要配置任何东西——Sass内置了全部实用功能，开箱即用。 然而，PostCSS需要你做一些配置。你不得不从一眼看不到底的<a href="https://github.com/postcss/postcss/blob/master/docs/plugins.md" target="_blank" rel="noopener">插件列表</a>选择插件并且自己把全部插件一起配置。但这同时意味着它的自定义程度高,足够实现你想要的。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>PostCSS在以惊人的速度发展，而且越来越受人欢迎。越来越多的人开始在了解它，使用它。因为他们意识到，在项目中使用PostCSS让他们意识到了眼前一亮。</p><p><img src="http://www.w3cplus.com/sites/default/files/blogs/2015/1510/postcssdownloads.png" alt></p><p>2014年总共不到140万的下载量，但从2015年1月份到6月份已经超过380万个下载。</p><p><strong><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a></strong>是PostCSS中最流行的插件，其中Google、Shopify、Twitter、Bootstrap和Codepen都在使用这个插件。Wordpress也使用Autoprefixer插件，而且还使用RTLCSS插件。Alibaba使用了几个PostCSS插件，以及也参加PostCSS的开发。</p><h2 id="运行PostCSS"><a href="#运行PostCSS" class="headerlink" title="运行PostCSS"></a>运行PostCSS</h2><p>运行PostCSS的方法有很多种。你可以很容易地将它添加到Gulp、webpack的构建过程中；<br>或者是通过最简单的方式,即postcss-cli来构建都是OK的,但因为我是习惯使用gulp,所以接下来介绍的是通过gulp配置,如果想使用其他方式构建，请自行度娘或google。</p><p>在已经安装了gulp的配置环境下,我们直接开始进行postCSS的配置.</p><h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><p>首先在你的项目中创建两个文件夹，一个命名为src，另一个命名为dest。src文件夹用来放置未处理的CSS文件，而dest用来放置PostCSS插件处理后的文件。</p><p>接下来需要做的就是在你的项目中安装gulp-postcss插件，安装好之后就可以使用PostCSS处理器。</p><p>打开你的命令终端(CMD)，并且进入到你的项目根目录下，然后在命令终端输入下面的命令：</p><pre><code>npm install --save-dev gulp-postcss</code></pre><p>安装完成后你的项目结构看起来就应该像这样：<br><img src="http://www.w3cplus.com/sites/default/files/blogs/2015/1510/gulpproject.png" alt></p><p>现在通过编辑器打开gulpfile.js文件，并且创建gulp和gulp-postcss变量，如下面代码所示：</p><pre><code>var gulp = require(&apos;gulp&apos;); var postcss = require(&apos;gulp-postcss&apos;);</code></pre><p>那我们现在可以设置一个任务，让PostCSS读取CSS原文件并且处理它。</p><p>添加的代码如下：</p><pre><code>gulp.task(&apos;css&apos;, function () {  var processors = [ ];  return gulp.src(&apos;./src/*.css&apos;).pipe(postcss(processors)).pipe(gulp.dest(&apos;./dest&apos;)); });</code></pre><p>我们一起来看一下上面的代码。在第一行，设置了一个任务名叫css。这个任务将会执行一个函数，同时在这个函数中创建了一个名为processors的数组。现在这个数组为空，这里将插入我们想使用的PostCSS插件。<br>在processors数组后面，我们指定了需要处理的目标文件，即src目录中的任何CSS文件。</p><p>这里面使用了两个.pipe()函数，设置postcss()执行PostCSS，并且给postcss()传递processors参数，后面会告诉PostCSS要使用哪个插件。</p><p>接下来的第二个.pipe()函数，指定结过PostCSS处理后的CSS放置在dest文件夹中。</p><h3 id="添加PostCSS插件"><a href="#添加PostCSS插件" class="headerlink" title="添加PostCSS插件"></a>添加PostCSS插件</h3><p>假设,现在我们添加需要的PostCSS插件：<strong>Autoprefixer</strong>(处理浏览器私有前缀)著作权归作者所有。<br>运行下面的命令，将插件安装到你的项目:</p><pre><code>npm install autoprefixer --save-dev</code></pre><p>接下来，在我们的项目中定义变量，将这些插件加载到我们的项目中。和前面的方式一样，在<strong>gulpfile.js</strong>文件中添加下面的代码：</p><pre><code>var autoprefixer = require(&apos;autoprefixer&apos;);</code></pre><p>然后将这个插件添加到processors数组中，更新后的数组如下：</p><pre><code>var processors = [ autoprefixer];</code></pre><p>插件已经添加到了<code>processors</code>数组中了，这个时候<code>PostCSS</code>会知道将这些插件功能应用到我们的CSS源文件中。</p><h3 id="测试编译"><a href="#测试编译" class="headerlink" title="测试编译"></a>测试编译</h3><p>在src目录中创建一个测试文件style.css，并在这个文件中添加一些CSS的测试代码：</p><pre><code> /* Testing autoprefixer */ .autoprefixer { display: flex; }</code></pre><p>在命令终端执行<code>gulp css</code>命令。在dest目录生成的文件会有下面的代码：</p><pre><code>/* Testing autoprefixer */ .autoprefixer {     display: -webkit-box;    display: -webkit-flex;    display: -ms-flexbox;    display: flex; }</code></pre><p>如上面编译出来的代码你应该看到了Autoprefixer给需要的属性添加了浏览器的私有前缀，编译符合需求的代码。</p><h4 id="设置插件选项"><a href="#设置插件选项" class="headerlink" title="设置插件选项"></a>设置插件选项</h4><p>注：每一个插件都有对应的配置参数选项，如果你想为一个插件配置选项参数，你可以在gulpfile.js文件中,在插件后面添加一对括号，并在里面传递选项的参数。例如，Autoprefixer需要指定对应的浏览器列表参数，你可以像这样设置：</p><pre><code>var processors = [     autoprefixer({browsers: [&apos;last 1 version&apos;]})];</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>通过<code>npm</code>(或<code>cnpm</code>)创建项目，并且将<code>gulp</code>安装到<code>gulpfile</code>文件</li><li>安装<code>gulp-postcss</code>插件</li><li>设置你的<code>gulpfile.js</code>文件，将<code>gulp</code>和<code>gulp-postcss</code>加载到项目中</li><li>创建一个任务，来编译你的<code>CSS</code></li><li>在任务中，设置一个<code>processors</code>数组</li><li>在<code>.pipe()</code>设置<code>一个postcss()</code>函数，并且将<code>processors</code>传递给它</li></ol><p>你可以根据上面的教程介绍，遵循相同的步骤，你可以将<code>PostCSS</code>任何插件安装到项目中。</p><p>通过<code>npm install &lt;plugin_name&gt; –save-dev</code> 命令将插件安装到你的项目中<br>类似<code>var autoprefixer = require(&quot;autoprefixer&quot;)</code>代码在你的<code>gulpfile.js</code>文件中定义要加载的插件变量名<br>将变量名添加到你的<code>preprocessors</code>数组中</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h1><p>(WEB前端)[Markdown|简历]<br>线上简历地址:<a href="http://www.xposean.top/about" target="_blank" rel="noopener">http://www.xposean.top/about</a></p><blockquote><p>个人技术博客：<a href="http://www.xposean.top/" target="_blank" rel="noopener">http://www.xposean.top/</a></p></blockquote><blockquote><p>Github：<a href="https://github.com/Anonlyy" target="_blank" rel="noopener">https://github.com/Anonlyy</a></p></blockquote><hr><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>许胜安 / 男 / 1996</p><p>专科/广东科学技术职业学院计算机学院软件技术专业 </p><p>工作年限：3年</p><p>喜好用户体验领域</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>手机：<span style="color:#7cafc2">13160663115</span> or  <span style="color:#a1b56c">13592742070</span></li><li>Email：<a href="mailto:843095666@qq.com" target="_blank" rel="noopener">843095666@qq.com</a> / <a href="mailto:qq843095666@gmail.com" target="_blank" rel="noopener">qq843095666@gmail.com</a></li><li>QQ/微信号：843095666</li></ul><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="天融信"><a href="#天融信" class="headerlink" title="天融信"></a>天融信</h3><p>前端小组 leader, 小组主要负责 天融信超融合平台产品的前端界面开发， 产品类型为<code>PC</code> <code>H5</code>页面, 已提供给全国上千家客户使用。</p><ul><li>主导前端项目的 开发, 负责 需求任务拆分、项目进度跟进, 以及个别难度较大的技术方案预研和实施。</li><li>在职期间, 对 前端项目 做 <strong>开发流程梳理优化</strong>, 并重新制定了 前端与UI对接流程、部署打包流程，极大提高了对接效率, 降低了出错率。</li><li>入职后,  由于项目前期开发一度追求速度,留下了大量的隐藏问题, 随着代码量和项目越发的庞大后, 问题逐渐都暴露出来,已严重影响到开发效率，所以在充分了解项目代码后, 制定了项目改造方案，带领团队成员进行改造重构, 综合项目开发进度和项目代码庞大等情况, 花了近7个月才完成, <strong>完成后降低前端BUG量、提高了前端开发效率, 极大改善了以往对前端团队的开发不信任感和不良印象</strong>, 改造内容包括且不限于:<ol><li>全局API调用方式重新封装、</li><li>引入esLint、styleLint, 团队开发只能有一种代码风格。 </li><li>配合项目增加前端权限管理系统，</li><li>使用vuex,并划分模块、</li><li>升级和优化webpack配置(打包速度提升50%、打包后的项目大小降低30%)</li><li>制定git commit 提交规范</li><li>其他…</li></ol></li><li>使用 <code>jekins</code> <code>gitlab</code> 为项目增加了自动化部署打包的功能 </li></ul><h3 id="大头兄弟"><a href="#大头兄弟" class="headerlink" title="大头兄弟"></a>大头兄弟</h3><p>前端团队(三名组员),团队主要负责进行短视频模板云端渲染的前端开发,产品类型为微信小程序和H5,已开发<strong>视频工场</strong>、<strong>魔性线条人</strong>、<strong>99MV</strong>、<strong>福福小视频</strong>等短视频模板小程序。以及负责公司APP的H5页面开发</p><h4 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h4><ul><li>主导公司的微信小程序开发,负责需求任务拆分、项目进度跟进,技术方案预研和敲定。</li><li>因小程序产品多且发布频率高的原因,基于wepy框架,封装了一系列相关的方法(包括视频组件、请求、登录、埋点),<br>提高了公司小程序产品的开发效率以及缩短开发周期。</li><li>因长期使用小程序视频组件,踩了不少坑,也研究了相关的优化方法,并封装了对应的组件。</li><li>小程序性能优化,如分包加载、分包预加载,资源代码打包压缩,数据缓存,提高小程序首屏加载速度。</li></ul><h4 id="APP混合H5开发"><a href="#APP混合H5开发" class="headerlink" title="APP混合H5开发"></a>APP混合H5开发</h4><ul><li>参与开发<strong>字说</strong>、<strong>逗拍</strong>APP内VIP、分享页等H5相关页面开发</li><li>后续重构该项目, 优化首屏加载速度, 使用cdn缓存等方式, 应对双11活动</li></ul><h2 id="业余作品"><a href="#业余作品" class="headerlink" title="业余作品"></a>业余作品</h2><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><ul><li><a href="https://github.com/Anonlyy/wx_iciba" target="_blank" rel="noopener">wx_iciba</a>： 微信小程序基于wepy框架开发-金山词霸。</li><li><a href="https://github.com/Anonlyy/ONE_Angular" target="_blank" rel="noopener">ONE_Angular</a>： 基于Angular4框架的「ONE一个」SPA应用。<br>预览地址: <a href="http://www.xposean.xin/ONE/" target="_blank" rel="noopener">http://www.xposean.xin/ONE/</a></li><li><a href="https://github.com/Anonlyy/ONE_Vue" target="_blank" rel="noopener">ONE_Vue</a>:基于vue.js框架的「ONE一个」SPA应用<br>预览地址: <a href="http://www.xposean.xin/ONE_vue" target="_blank" rel="noopener">http://www.xposean.xin/ONE_vue</a></li><li><a href="https://github.com/Anonlyy/iWeather" target="_blank" rel="noopener">iWeather</a>： vue2.0构建的天气webAPP。</li><li><a href="https://github.com/Anonlyy/shareMusic" target="_blank" rel="noopener">ShareMusic</a>：这是一款基于Anuglar4框架的音乐播放器,并使用网易云音乐API,样式布局则参考QQ音乐客户端.</li><li><a href="https://github.com/Anonlyy/loveWall" target="_blank" rel="noopener">loveWall</a>:毕设作品,基于原生微信小程序开发的APP</li></ul><h3 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h3><ul><li><a href="https://juejin.im/post/5b31d98ee51d4558817e14f8" target="_blank" rel="noopener">html2canvas的踩坑之路</a></li><li><a href="http://www.xposean.xin/2018/03/08/%E8%A2%AB%E4%B8%A5%E9%87%8D%E4%BD%8E%E4%BC%B0%E7%9A%84target-blank-%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">被严重低估的target=’_blank’漏洞问题</a></li><li><a href="https://juejin.im/post/5b173ab7f265da6e4d5af75f~~~~" target="_blank" rel="noopener">来看看Service Worker的项目实战</a></li><li><a href="http://www.xposean.xin/2017/10/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87/" target="_blank" rel="noopener">前端性能优化之图片</a></li><li><a href="https://juejin.im/post/5b98f8f26fb9a05cfb3d9c7b" target="_blank" rel="noopener">virtual DOM快在哪里?</a></li><li><a href="http://www.xposean.xin/2017/10/24/%E5%BD%B1%E5%93%8D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%83%E5%87%B6-DOM%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener">影响前端性能的元凶:DOM操作</a>  </li><li><a href="http://www.xposean.xin/2017/10/24/jQuery%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">jQuery的插件机制</a>  </li></ul><h2 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h2><ul><li>熟悉HTML5、CSS3、JavaScript</li><li>熟悉使用微信小程序开发和Vue框架开发</li><li>熟悉前后端分离开发模式、web语义化</li><li>熟悉SASS、LESS等CSS预编译器、及PostCSS后编译器</li><li>熟练使用Gulp工作流、webpack等开发工具</li><li>熟练使用git、svn版本控制和团队协同工具</li><li>熟悉处理PC端页面兼容、移动端页面兼容性问题</li></ul><h2 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h2><ul><li>Keep健身</li><li>热衷技术,喜欢刨根问底,找寻问题根源</li><li>爱到墙外的世界去看看</li></ul><hr><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/file/virtualDom/diff-reorder.js"/>
      <url>/file/virtualDom/diff-reorder.js</url>
      
        <content type="html"><![CDATA[/** * Diff two list in O(N). * @param {Array} oldList - Original List * @param {Array} newList - List After certain insertions, removes, or moves * @return {Object} - {moves: <array>} *                  - moves is a list of actions that telling how to remove and insert */function diff (oldList, newList, key) {  var oldMap = makeKeyIndexAndFree(oldList, key)  var newMap = makeKeyIndexAndFree(newList, key)  var newFree = newMap.free  var oldKeyIndex = oldMap.keyIndex  var newKeyIndex = newMap.keyIndex  var moves = []  // 模拟列表操作  var children = []  var i = 0  var item  var itemKey  var freeIndex = 0  // first pass to check item in old list: if it's removed or not  while (i < oldList.length) {    item = oldList[i]    itemKey = getItemKey(item, key)    if (itemKey) {      if (!newKeyIndex.hasOwnProperty(itemKey)) {        children.push(null)      } else {        var newItemIndex = newKeyIndex[itemKey]        children.push(newList[newItemIndex])      }    } else {      var freeItem = newFree[freeIndex++]      children.push(freeItem || null)    }    i++  }  var simulateList = children.slice(0)  // remove items no longer exist  i = 0  while (i < simulateList.length) {    if (simulateList[i] === null) {      remove(i)      removeSimulate(i)    } else {      i++    }  }  // i is cursor pointing to a item in new list  // j is cursor pointing to a item in simulateList  var j = i = 0  while (i < newList.length) {    item = newList[i]    itemKey = getItemKey(item, key)    var simulateItem = simulateList[j]    var simulateItemKey = getItemKey(simulateItem, key)    if (simulateItem) {      if (itemKey === simulateItemKey) {        j++      } else {        // new item, just inesrt it        if (!oldKeyIndex.hasOwnProperty(itemKey)) {          insert(i, item)        } else {          // if remove current simulateItem make item in right place          // then just remove it          var nextItemKey = getItemKey(simulateList[j + 1], key)          if (nextItemKey === itemKey) {            remove(i)            removeSimulate(j)            j++ // after removing, current j is right, just jump to next one          } else {            // else insert item            insert(i, item)          }        }      }    } else {      insert(i, item)    }    i++  }  //if j is not remove to the end, remove all the rest item  var k = simulateList.length - j  while (j++ < simulateList.length) {    k--    remove(k + i)  }  function remove (index) {    var move = {index: index, type: 0}    moves.push(move)  }  function insert (index, item) {    var move = {index: index, item: item, type: 1}    moves.push(move)  }  function removeSimulate (index) {    simulateList.splice(index, 1)  }  return {    moves: moves,    children: children  }}/** * Convert list to key-item keyIndex object. * @param {Array} list * @param {String|Function} key */function makeKeyIndexAndFree (list, key) {  var keyIndex = {}  var free = []  for (var i = 0, len = list.length; i < len; i++) {    var item = list[i]    var itemKey = getItemKey(item, key)    if (itemKey) {      keyIndex[itemKey] = i    } else {      free.push(item)    }  }  return {    keyIndex: keyIndex,    free: free  }}function getItemKey (item, key) {  if (!item || !key) return void 666  return typeof key === 'string'    ? item[key]    : setItemkey(item)}exports.makeKeyIndexAndFree = makeKeyIndexAndFree // exports for testexports.diff = diff</array>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/file/virtualDom/diff.js"/>
      <url>/file/virtualDom/diff.js</url>
      
        <content type="html"><![CDATA[// 比对差异,并记录起来var patch = {    'REPLACE' : 0, // 替换    'REORDER' : 1, // 新增、删除、移动    'PROPS' : 2, // 属性更改    'TEXT' : 3 // 文本内容更改}// diff 函数,对比两棵DOM树function diff (oldTree, newTree) {  var index = 0 // 当前节点的标志  var patches = {} // 用来记录每个节点差异的对象  dfsWalk(oldTree, newTree, index, patches)  return patches}// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) {  var currentPatch = []  // 新节点被删除  if (newNode === null) {   // 真正的DOM节点在执行重新排序时会被删除，所以在这里不需要做操作  // 文本节点内容被更改  } else if (_.isString(oldNode) && _.isString(newNode)) {    if (newNode !== oldNode) {      currentPatch.push({ type: patch.TEXT, content: newNode }) // 存入差异数组    }  // 节点标签一致,但属性不同或子节点不同   } else if (oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) {    // 不同的属性    var propsPatches = diffProps(oldNode, newNode) // 返回属性列表    if (propsPatches) {      currentPatch.push({ type: patch.PROPS, props: propsPatches }) // 存入差异数组    }    // 子节点不同    diffChildren(        oldNode.children,        newNode.children,        index,        patches,        currentPatch      )  // 节点不一致,替换成新节点  } else {    currentPatch.push({ type: patch.REPLACE, node: newNode }) // 存入差异数组  }  if (currentPatch.length) {    // 对比oldNode和newNode的不同，记录下来    patches[index] = currentPatch  }}// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches, currentPatch) {  // 针对新增、移动、删除情况  // 传入两个DOM树,并输出标记过的节点数组(标记了新节点的顺序、包括删除和新增)  /**   *  type：remove moves[0] = {index: index, type: 0}   *  type：add、insert moves[0] = {index: index, item: item, type: 1}   */  var diffs = listDiff(oldChildren, newChildren, 'key')  newChildren = diffs.children  if (diffs.moves.length) {    var reorderPatch = { type: patch.REORDER, moves: diffs.moves }    currentPatch.push(reorderPatch) // 存入差异数组  }  var leftNode = null  var currentNodeIndex = index  oldChildren.forEach(function (child, i) {    var newChild = newChildren[i]    currentNodeIndex = (leftNode && leftNode.count) // 计算节点的标识      ? currentNodeIndex + leftNode.count + 1      : currentNodeIndex + 1    dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点    leftNode = child  })}// 对比 同个节点 不同的属性function diffProps (oldNode, newNode) {  var count = 0  var oldProps = oldNode.props  var newProps = newNode.props  var key, value  var propsPatches = {}  // 对比不同的属性  for (key in oldProps) {    value = oldProps[key]    if (newProps[key] !== value) {      count++      propsPatches[key] = newProps[key]    }  }  // 找到新属性  for (key in newProps) {    value = newProps[key]    if (!oldProps.hasOwnProperty(key)) {      count++      propsPatches[key] = newProps[key]    }  }  // 如果所有属性一致  if (count === 0) {    return null  }  return propsPatches}function isIgnoreChildren (node) {  return (node.props && node.props.hasOwnProperty('ignore'))}module.exports = diff]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/file/virtualDom/element.js"/>
      <url>/file/virtualDom/element.js</url>
      
        <content type="html"><![CDATA[// 1.创建虚拟DOM函数function Element (tagName, props, children) {  this.tagName = tagName  this.props = props  this.children = children}// 2.构建真实DOM函数Element.prototype.render = function () {  var el = document.createElement(this.tagName) // 根据tagName构建  var props = this.props  for (var propName in props) { // 设置节点的DOM属性    var propValue = props[propName]    el.setAttribute(propName, propValue)  }  var children = this.children || []  children.forEach(function (child) {    var childEl = (child instanceof Element)      ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点      : document.createTextNode(child) // 如果字符串，只构建文本节点    el.appendChild(childEl)  })  return el}// 使用var ul = Element('ul', {id: 'list'}, [  Element('li', {class: 'item'}, ['Item 1']),  Element('li', {class: 'item'}, ['Item 2']),  Element('li', {class: 'item'}, ['Item 3'])])// 插入真实DOM中var ulRoot = ul.render()document.body.appendChild(ulRoot)]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/file/virtualDom/patch.js"/>
      <url>/file/virtualDom/patch.js</url>
      
        <content type="html"><![CDATA[var _ = require('./util')var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3// 开始执行DOM操作function patch (node, patches) {  var walker = {index: 0}  dfsWalk(node, walker, patches)}function dfsWalk (node, walker, patches) {  var currentPatches = patches[walker.index]  var len = node.childNodes    ? node.childNodes.length    : 0  for (var i = 0; i < len; i++) {    var child = node.childNodes[i]    walker.index++    // 递归遍历patches数组    dfsWalk(child, walker, patches)  }  if (currentPatches) {    // 根据差异属性进行DOM操作    applyPatches(node, currentPatches)  }}// 开始执行DOM操作function applyPatches (node, currentPatches) {  currentPatches.forEach(function (currentPatch) {    switch (currentPatch.type) { // 根据差异类型做不同DOM操作      case REPLACE:        var newNode = (typeof currentPatch.node === 'string')          ? document.createTextNode(currentPatch.node)          : currentPatch.node.render()        node.parentNode.replaceChild(newNode, node) // 直接替换        break      case REORDER:        reorderChildren(node, currentPatch.moves)        break      case PROPS:        setProps(node, currentPatch.props)        break      case TEXT:        if (node.textContent) {          node.textContent = currentPatch.content        } else {          // 兼容IE          node.nodeValue = currentPatch.content        }        break      default:        throw new Error('Unknown patch type ' + currentPatch.type)    }  })}// 设置节点属性function setProps (node, props) {  for (var key in props) {    if (props[key] === void 666) {      node.removeAttribute(key)    } else {      var value = props[key]      _.setAttr(node, key, value)    }  }}// 重新排序节点(并将删除的节点,从列表中剔除)function reorderChildren (node, moves) {  var staticNodeList = node.childNodes // 拿到经过标记后的数组  var maps = {}  staticNodeList.forEach(function (node) {    if (node.nodeType === 1) {      var key = node.getAttribute('key')      if (key) {        maps[key] = node      }    }  })  // 根据type操作DOM  moves.forEach(moves, function (move) {    var index = move.index    if (move.type === 0) { // 直接从列表中删除      if (staticNodeList[index] === node.childNodes[index]) {        node.removeChild(node.childNodes[index])      }      staticNodeList.splice(index, 1)    } else if (move.type === 1) { // insert item      var insertNode = maps[move.item.key]        ? maps[move.item.key].cloneNode(true) // reuse old item        : (typeof move.item === 'object')            ? move.item.render()            : document.createTextNode(move.item)      staticNodeList.splice(index, 0, insertNode)      node.insertBefore(insertNode, node.childNodes[index] || null)    }  })}patch.REPLACE = REPLACEpatch.REORDER = REORDERpatch.PROPS = PROPSpatch.TEXT = TEXTmodule.exports = patch]]></content>
      
    </entry>
    
    
  
</search>
