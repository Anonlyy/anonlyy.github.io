<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Xposean,qq843095666@gmail.com"><title>Virtual DOM原理概述 · Xposean's Blog</title><meta name="description" content="Virtual DOM概念的诞生先来说说Virtual DOM的起源,Virtual DOM的概念最早是在React中被提出来的,上一节我们也说了,DOM操作是十分耗费性能,因为动不动操作就会引发回流，即渲染整个DOM树,对于移动端浏览器或者是复杂的页面来讲,这简直就是噩梦。
于是,聪明的工程师们就"><meta name="keywords" content="JS,HTML,CSS,JavaScript"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Xposean's Blog</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="http://instagram.com/13160663115"><i class="fa fa-instagram"></i></a></li><li><a href="http://weibo.com/xposean"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/Anonlyy"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于我</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/img/avatar.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Virtual DOM原理概述</a></h3></div><div class="post-content"><p><img src="http://it.dyg.cn/wp-content/uploads/2017/10/timg-2.jpg" alt="Virtual DOM"></p>
<h2 id="Virtual-DOM概念的诞生"><a href="#Virtual-DOM概念的诞生" class="headerlink" title="Virtual DOM概念的诞生"></a>Virtual DOM概念的诞生</h2><p>先来说说<code>Virtual DOM</code>的起源,<code>Virtual DOM</code>的概念最早是在<code>React中</code>被提出来的,<a href="http://www.xposean.xin/2017/10/24/%E5%BD%B1%E5%93%8D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%83%E5%87%B6-DOM%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener">上一节</a>我们也说了,<code>DOM</code>操作是十分耗费性能,因为动不动操作就会引发回流，即渲染整个DOM树,对于移动端浏览器或者是复杂的页面来讲,这简直就是噩梦。</p>
<p>于是,聪明的工程师们就发明了一种<code>MVVM</code>模式,即视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。只要在模版中声明视图组件是和什么状态进行绑定的，通过改变状态，双向绑定引擎就会在状态更新的时候自动更新视图。</p>
<p>MVVM模式让我们大大减少代码中的DOM操作次数，其次可以提高<code>DOM</code>的渲染性能,因为他是通过模板引擎和JS构建修改DOM的,很大程度的减少了回流产生的次数。<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171022220758.png" alt></p>
<p>相对于 <code>DOM</code> 对象，原生的 <code>JavaScript</code> 对象处理起来更快，而且更简单。<code>DOM</code> 树上的结构、属性信息我们都可以很容易地用 <code>JavaScript</code> 对象表示出来。</p>
<p>但是它同时也存在什么问题呢?</p>
<p>那就是一旦我们所绑定的某一个状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧  的视图。</p>
<p>这样的做法会导致很多的问题。最大的问题就是这样做还是会很慢，因为即使一个小小的状态变更都要重新构造整棵 <code>DOM</code>，性价比太低；最后的结论会是：对于局部的小视图的更新，没有问题；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。</p>
<p><code>AngularJS</code>就是使用这个方式。</p>
<p>那么工程师经过改进呢,就发明了<code>Virtual DOM</code>啦!</p>
<h2 id="Virtual-DOM凭什么更加优秀"><a href="#Virtual-DOM凭什么更加优秀" class="headerlink" title="Virtual DOM凭什么更加优秀?"></a>Virtual DOM凭什么更加优秀?</h2><p>其实 <code>Virtual DOM</code> 跟MVVM模式是基本类似的，只是加了一些特别的步骤(diff)来避免了整棵 <code>DOM</code> 树变更。<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171022220758-1.png" alt></p>
<p><img src="https://camo.githubusercontent.com/a32766a14f6b7fbe631475ed1a186fbd9de7f2c3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f636f6d706172652d696e2d6c6576656c2e706e67" alt></p>
<h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面:"></a>性能方面:</h3><ol>
<li><p>用JS构建虚拟DOM树,再通过虚拟DOM构建真正的DOM,这种方式性能快的多。</p>
</li>
<li><p>如果我们直接调用像.getElementById的方法,在复杂DOM的页面上,是十分耗费性能的,而在这只需要操作对应的JS对象即可。</p>
</li>
<li>比较两棵虚拟DOM树的不同,在真正的DOM元素上进行最小化修改(模板引擎).</li>
</ol>
<h3 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面:"></a>代码方面:</h3><ol>
<li>MVVM模式下,也使我们无需关注DOM元素,直接操作DOM元素对应的状态就行,对于代码编辑更好。</li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-10-24</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://xposean.xin/2017/10/24/VirtualDOM原理概述/,Xposean's Blog,Virtual DOM原理概述,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/10/27/前端性能优化之图片/" title="前端性能优化之图片">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/10/24/影响前端性能的元凶-DOM操作/" title="影响前端性能的元凶:DOM操作">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'BvCCzMrHWUlCA2JyrOUcX5PT-gzGzoHsz',
  app_key:'jbompkWlXrluqMW2otxXNmSm',
  placeholder:'please input your comment',
  path: window.location.pathname,
  avatar:'identicon'
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>